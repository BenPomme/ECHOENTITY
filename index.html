<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ECHO - Emergent Communication with Hand Organisms</title>
    <meta name="description" content="An interactive 3D particle system that learns your gestures, recognizes faces, and communicates through visuals and spatial sound.">
    <meta property="og:title" content="ECHO - Emergent Communication">
    <meta property="og:description" content="Interactive AI that learns your hand gestures and responds with particles, shapes, and sound.">
    <meta property="og:type" content="website">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #000;
            font-family: 'Segoe UI', system-ui, sans-serif;
        }

        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #video {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 180px;
            height: 135px;
            border-radius: 12px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            transform: scaleX(-1);
            object-fit: cover;
            z-index: 100;
            opacity: 0.7;
            transition: border-color 0.3s;
        }

        #video.face-detected {
            border-color: rgba(80, 250, 123, 0.6);
        }

        #ui-panel {
            position: fixed;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 13px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(15px);
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 100;
            max-width: 300px;
        }

        #ui-panel h2 {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 12px;
            color: #8be9fd;
            letter-spacing: 2px;
        }

        .entity-state {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }

        .state-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #50fa7b;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(0.8); }
        }

        .user-badge {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 15px;
            padding: 10px;
            background: linear-gradient(135deg, rgba(189, 147, 249, 0.2), rgba(255, 121, 198, 0.2));
            border-radius: 8px;
            border: 1px solid rgba(189, 147, 249, 0.3);
        }

        .user-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: linear-gradient(135deg, #bd93f9, #ff79c6);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 14px;
        }

        .user-info {
            flex: 1;
        }

        .user-name {
            font-weight: 600;
            color: #f8f8f2;
        }

        .user-visits {
            font-size: 11px;
            opacity: 0.7;
        }

        .memory-bar {
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            margin-top: 8px;
            overflow: hidden;
        }

        .memory-fill {
            height: 100%;
            background: linear-gradient(90deg, #bd93f9, #ff79c6);
            border-radius: 2px;
            transition: width 0.3s;
        }

        #gesture-display {
            margin-top: 10px;
            font-family: monospace;
            font-size: 11px;
            color: #f1fa8c;
        }

        #entity-message {
            margin-top: 15px;
            padding: 12px;
            background: rgba(139, 233, 253, 0.1);
            border-radius: 8px;
            border-left: 3px solid #8be9fd;
            font-style: italic;
            min-height: 60px;
            transition: all 0.3s;
        }

        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            z-index: 200;
            text-align: center;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top-color: #8be9fd;
            border-radius: 50%;
            margin: 0 auto 20px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        #start-audio {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px 40px;
            font-size: 18px;
            background: linear-gradient(135deg, #bd93f9, #ff79c6);
            border: none;
            border-radius: 30px;
            color: white;
            cursor: pointer;
            z-index: 300;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        #start-audio:hover {
            transform: translate(-50%, -50%) scale(1.05);
            box-shadow: 0 10px 40px rgba(189, 147, 249, 0.4);
        }

        .hidden { display: none !important; }

        #resonance-visual {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 3px;
            z-index: 100;
        }

        .resonance-bar {
            width: 4px;
            height: 30px;
            background: linear-gradient(to top, #50fa7b, #8be9fd);
            border-radius: 2px;
            transform-origin: bottom;
            transition: transform 0.05s;
        }

        /* Name input modal */
        #name-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 400;
            backdrop-filter: blur(10px);
        }

        .modal-content {
            background: rgba(30, 30, 50, 0.95);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            border: 1px solid rgba(139, 233, 253, 0.3);
            max-width: 400px;
        }

        .modal-content h3 {
            color: #8be9fd;
            margin-bottom: 10px;
            font-size: 24px;
        }

        .modal-content p {
            color: rgba(255, 255, 255, 0.7);
            margin-bottom: 25px;
            line-height: 1.6;
        }

        .modal-content input {
            width: 100%;
            padding: 15px;
            border: 2px solid rgba(139, 233, 253, 0.3);
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.3);
            color: white;
            font-size: 16px;
            margin-bottom: 20px;
            outline: none;
            transition: border-color 0.3s;
        }

        .modal-content input:focus {
            border-color: #8be9fd;
        }

        .modal-content button {
            padding: 15px 40px;
            font-size: 16px;
            background: linear-gradient(135deg, #bd93f9, #ff79c6);
            border: none;
            border-radius: 25px;
            color: white;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .modal-content button:hover {
            transform: scale(1.05);
        }

        .face-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 15px;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            color: white;
            font-size: 12px;
            z-index: 100;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .face-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ff5555;
            transition: background 0.3s;
        }

        .face-dot.active {
            background: #50fa7b;
            animation: pulse 1s infinite;
        }

        #known-users {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        #known-users h4 {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.5);
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .known-user-list {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }

        .known-user-chip {
            padding: 4px 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            font-size: 11px;
            color: rgba(255, 255, 255, 0.7);
        }

        .known-user-chip.current {
            background: rgba(80, 250, 123, 0.2);
            color: #50fa7b;
        }

        /* Multiplayer / Online users panel */
        #online-panel {
            position: fixed;
            top: 20px;
            right: 220px;
            color: white;
            font-size: 12px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(15px);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 100;
            min-width: 180px;
        }

        .online-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .online-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #50fa7b;
            animation: pulse 2s infinite;
        }

        .online-count {
            font-weight: 600;
            color: #50fa7b;
        }

        .online-users-list {
            max-height: 120px;
            overflow-y: auto;
        }

        .online-user {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 5px 0;
            font-size: 11px;
        }

        .online-user-avatar {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #bd93f9, #ff79c6);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
        }

        .online-user.self .online-user-avatar {
            background: linear-gradient(135deg, #50fa7b, #8be9fd);
        }

        /* Messages panel */
        #messages-panel {
            position: fixed;
            bottom: 180px;
            right: 20px;
            width: 280px;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(15px);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 100;
            overflow: hidden;
        }

        .messages-header {
            padding: 12px 15px;
            background: rgba(255, 255, 255, 0.05);
            font-size: 12px;
            font-weight: 600;
            color: #8be9fd;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .messages-list {
            height: 150px;
            overflow-y: auto;
            padding: 10px;
        }

        .message {
            margin-bottom: 10px;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .message-sender {
            font-size: 10px;
            color: #bd93f9;
            margin-bottom: 2px;
        }

        .message-text {
            font-size: 12px;
            color: #f8f8f2;
            background: rgba(255, 255, 255, 0.05);
            padding: 8px 10px;
            border-radius: 8px;
            word-wrap: break-word;
        }

        .message.self .message-text {
            background: rgba(80, 250, 123, 0.15);
        }

        .message.system .message-text {
            background: rgba(139, 233, 253, 0.15);
            font-style: italic;
            color: #8be9fd;
        }

        .message-input-container {
            display: flex;
            gap: 8px;
            padding: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        #message-input {
            flex: 1;
            padding: 8px 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            background: rgba(0, 0, 0, 0.3);
            color: white;
            font-size: 12px;
            outline: none;
        }

        #message-input:focus {
            border-color: #8be9fd;
        }

        #send-message-btn {
            padding: 8px 15px;
            background: linear-gradient(135deg, #bd93f9, #ff79c6);
            border: none;
            border-radius: 20px;
            color: white;
            font-size: 12px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        #send-message-btn:hover {
            transform: scale(1.05);
        }

        /* Global activity indicator */
        .global-activity {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            padding: 8px 20px;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            color: white;
            font-size: 12px;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        .global-activity.visible {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div id="loading">
        <div class="spinner"></div>
        <div>Awakening ECHO...</div>
        <div style="font-size: 12px; opacity: 0.6; margin-top: 10px;">Loading hand & face recognition...</div>
    </div>

    <div id="name-modal" class="hidden">
        <div class="modal-content">
            <h3>Welcome to ECHO</h3>
            <p>I'm an emergent entity that learns from you. I can recognize your face and remember our interactions. What should I call you?</p>
            <input type="text" id="user-name-input" placeholder="Enter your name..." maxlength="20">
            <button id="save-name-btn">Begin Connection</button>
        </div>
    </div>

    <button id="start-audio" class="hidden">Enter ECHO's World</button>

    <div class="face-indicator hidden" id="face-indicator">
        <div class="face-dot"></div>
        <span id="face-status">No face detected</span>
    </div>

    <div id="ui-panel" class="hidden">
        <h2>◈ ECHO ENTITY</h2>

        <div class="user-badge hidden" id="user-badge">
            <div class="user-avatar" id="user-avatar">?</div>
            <div class="user-info">
                <div class="user-name" id="current-user-name">Unknown</div>
                <div class="user-visits" id="user-visits">First visit</div>
            </div>
        </div>

        <div class="entity-state">
            <div class="state-indicator"></div>
            <div>
                <div id="entity-mood">Curious</div>
                <div style="font-size: 11px; opacity: 0.6;">Current State</div>
            </div>
        </div>

        <div>
            <div style="display: flex; justify-content: space-between; font-size: 11px;">
                <span>Pattern Memory</span>
                <span id="memory-count">0 gestures</span>
            </div>
            <div class="memory-bar">
                <div class="memory-fill" id="memory-fill" style="width: 0%"></div>
            </div>
        </div>

        <!-- Evolution Stage Display -->
        <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.1);">
            <div style="display: flex; justify-content: space-between; font-size: 11px; margin-bottom: 4px;">
                <span>Evolution</span>
                <span id="evolution-stage">Primordial</span>
            </div>
            <div class="memory-bar">
                <div class="memory-fill" id="evolution-fill" style="width: 0%; background: linear-gradient(90deg, #8be9fd, #bd93f9, #ff79c6);"></div>
            </div>
            <div id="mimetic-stats" style="font-size: 9px; color: rgba(255,255,255,0.5); margin-top: 4px;">
                Hands: 0 | Faces: 0 | Memories: 0
            </div>
        </div>

        <div id="gesture-display">
            Last detected: None
        </div>

        <div id="entity-message">
            <em>"I sense nothing yet... show me your hands..."</em>
        </div>

        <div id="known-users" class="hidden">
            <h4>Known Visitors</h4>
            <div class="known-user-list" id="known-user-list"></div>
        </div>
    </div>

    <!-- Online users panel -->
    <div id="online-panel" class="hidden">
        <div class="online-header">
            <div class="online-dot"></div>
            <span><span class="online-count" id="online-count">1</span> soul(s) connected</span>
        </div>
        <div class="online-users-list" id="online-users-list">
            <!-- Populated by JS -->
        </div>
    </div>

    <!-- Messages panel -->
    <div id="messages-panel" class="hidden">
        <div class="messages-header">Universal Messages</div>
        <div class="messages-list" id="messages-list">
            <!-- Populated by JS -->
        </div>
        <div class="message-input-container">
            <input type="text" id="message-input" placeholder="Send a message to all..." maxlength="200">
            <button id="send-message-btn">Send</button>
        </div>
    </div>

    <!-- Global activity notification -->
    <div class="global-activity" id="global-activity"></div>

    <div id="canvas-container"></div>
    <video id="video" autoplay playsinline></video>

    <div id="resonance-visual"></div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
        }
    }
    </script>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.0/firebase-database-compat.js"></script>

    <script type="module">
        import * as THREE from 'three';

        // ════════════════════════════════════════════════════════════════
        // FIREBASE CONFIGURATION
        // ════════════════════════════════════════════════════════════════
        const firebaseConfig = {
            apiKey: "AIzaSyDVcTqOKuhj7ckhTK0vti1L00OivKI-KUs",
            authDomain: "echo-3e1b5.firebaseapp.com",
            databaseURL: "https://echo-3e1b5-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "echo-3e1b5",
            storageBucket: "echo-3e1b5.firebasestorage.app",
            messagingSenderId: "1086326455258",
            appId: "1:1086326455258:web:f18477dcb5052384cadee3",
            measurementId: "G-PCQ25JT6YP"
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const database = firebase.database();

        // ════════════════════════════════════════════════════════════════
        // MULTIPLAYER SYSTEM
        // ════════════════════════════════════════════════════════════════
        class MultiplayerSystem {
            constructor() {
                this.sessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                this.currentUser = null;
                this.onlineUsers = {};
                this.presenceRef = null;
                this.usersRef = database.ref('presence');
                this.messagesRef = database.ref('messages');
                this.activityRef = database.ref('activity');
                this.initialized = false;
                this.lastPresenceUpdate = 0;
                this.otherUsersGestures = []; // Track gestures from other users
                this.onGestureCallbacks = []; // Callbacks for when others make gestures
            }

            async init(userName) {
                this.currentUser = {
                    id: this.sessionId,
                    name: userName,
                    joinedAt: Date.now(),
                    lastActivity: Date.now(),
                    gesture: null,
                    mood: 'curious'
                };

                // Set up presence
                this.presenceRef = this.usersRef.child(this.sessionId);

                // Store user data
                await this.presenceRef.set(this.currentUser);

                // Remove user on disconnect
                this.presenceRef.onDisconnect().remove();

                // Listen for online users and their gestures
                this.usersRef.on('value', (snapshot) => {
                    const oldUsers = this.onlineUsers;
                    this.onlineUsers = snapshot.val() || {};
                    this.updateOnlineUsersUI();

                    // Track gesture changes from other users
                    this.otherUsersGestures = [];
                    for (const [id, user] of Object.entries(this.onlineUsers)) {
                        if (id !== this.sessionId && user.gesture) {
                            this.otherUsersGestures.push({
                                name: user.name,
                                gesture: user.gesture,
                                mood: user.mood
                            });

                            // Check if gesture changed
                            const oldUser = oldUsers[id];
                            if (!oldUser || oldUser.gesture !== user.gesture) {
                                // Notify callbacks about the gesture
                                this.onGestureCallbacks.forEach(cb => cb(user.name, user.gesture, user.mood));
                            }
                        }
                    }
                });

                // Listen for new users joining
                this.usersRef.on('child_added', (snapshot) => {
                    const user = snapshot.val();
                    if (user.id !== this.sessionId) {
                        this.showGlobalActivity(`${user.name} joined the experience`);
                    }
                });

                // Listen for users leaving
                this.usersRef.on('child_removed', (snapshot) => {
                    const user = snapshot.val();
                    if (user) {
                        this.showGlobalActivity(`${user.name} left the experience`);
                    }
                });

                // Listen for messages (last 50)
                this.messagesRef.orderByChild('timestamp').limitToLast(50).on('child_added', (snapshot) => {
                    const message = snapshot.val();
                    this.addMessageToUI(message);
                });

                // Listen for activity broadcasts
                this.activityRef.on('child_added', (snapshot) => {
                    const activity = snapshot.val();
                    if (activity.userId !== this.sessionId && Date.now() - activity.timestamp < 5000) {
                        this.showGlobalActivity(activity.text);
                    }
                    // Clean up old activities
                    if (Date.now() - activity.timestamp > 10000) {
                        snapshot.ref.remove();
                    }
                });

                this.initialized = true;
                console.log('Multiplayer initialized');

                // Send join message
                this.sendSystemMessage(`${userName} has connected to ECHO`);

                return this.currentUser;
            }

            updatePresence(gesture, mood) {
                if (!this.initialized || !this.presenceRef) return;

                this.presenceRef.update({
                    lastActivity: Date.now(),
                    gesture: gesture || null,
                    mood: mood
                });
            }

            broadcastActivity(text) {
                if (!this.initialized) return;

                this.activityRef.push({
                    userId: this.sessionId,
                    userName: this.currentUser.name,
                    text: text,
                    timestamp: Date.now()
                });
            }

            sendMessage(text) {
                if (!this.initialized || !text.trim()) return;

                this.messagesRef.push({
                    userId: this.sessionId,
                    userName: this.currentUser.name,
                    text: text.trim(),
                    timestamp: Date.now(),
                    type: 'user'
                });
            }

            sendSystemMessage(text) {
                if (!this.initialized) return;

                this.messagesRef.push({
                    userId: 'system',
                    userName: 'ECHO',
                    text: text,
                    timestamp: Date.now(),
                    type: 'system'
                });
            }

            updateOnlineUsersUI() {
                const usersList = document.getElementById('online-users-list');
                const countEl = document.getElementById('online-count');

                const users = Object.values(this.onlineUsers);
                countEl.textContent = users.length;

                usersList.innerHTML = users.map(user => {
                    const isSelf = user.id === this.sessionId;
                    const gestureText = user.gesture ? ` (${user.gesture})` : '';
                    return `
                        <div class="online-user ${isSelf ? 'self' : ''}">
                            <div class="online-user-avatar">${user.name.charAt(0).toUpperCase()}</div>
                            <span>${user.name}${isSelf ? ' (you)' : ''}${gestureText}</span>
                        </div>
                    `;
                }).join('');
            }

            addMessageToUI(message) {
                const messagesList = document.getElementById('messages-list');
                const isSelf = message.userId === this.sessionId;
                const isSystem = message.type === 'system';

                const messageEl = document.createElement('div');
                messageEl.className = `message ${isSelf ? 'self' : ''} ${isSystem ? 'system' : ''}`;
                messageEl.innerHTML = `
                    <div class="message-sender">${isSystem ? 'ECHO' : message.userName}</div>
                    <div class="message-text">${this.escapeHtml(message.text)}</div>
                `;

                messagesList.appendChild(messageEl);
                messagesList.scrollTop = messagesList.scrollHeight;

                // Keep only last 50 messages in UI
                while (messagesList.children.length > 50) {
                    messagesList.removeChild(messagesList.firstChild);
                }
            }

            escapeHtml(text) {
                const div = document.createElement('div');
                div.textContent = text;
                return div.innerHTML;
            }

            showGlobalActivity(text) {
                const activityEl = document.getElementById('global-activity');
                activityEl.textContent = text;
                activityEl.classList.add('visible');

                setTimeout(() => {
                    activityEl.classList.remove('visible');
                }, 3000);
            }

            getOnlineCount() {
                return Object.keys(this.onlineUsers).length;
            }

            getOtherUsersGestures() {
                return this.otherUsersGestures;
            }

            onOtherUserGesture(callback) {
                this.onGestureCallbacks.push(callback);
            }

            disconnect() {
                if (this.presenceRef) {
                    this.presenceRef.remove();
                }
            }
        }

        const multiplayer = new MultiplayerSystem();

        // ════════════════════════════════════════════════════════════════
        // COLLECTIVE LEARNING SYSTEM
        // ════════════════════════════════════════════════════════════════
        class CollectiveLearningSystem {
            constructor() {
                this.learnedGestures = new Map();      // gesture -> { count, lastSeen, users, contexts }
                this.gestureSequences = [];            // All gesture sequences (up to 10,000)
                this.transitionMatrix = new Map();     // gesture -> Map(nextGesture -> count)
                this.userPatterns = new Map();         // userName -> { gestures[], preferences }
                this.timePatterns = new Map();         // hour -> gesture frequency
                this.reproductionQueue = [];
                this.lastReproductionTime = 0;
                this.confidenceThreshold = 5;
                this.predictions = [];                 // Recent predictions for accuracy tracking
                this.predictionAccuracy = 0;
            }

            // Learn from a gesture with full context
            learn(gesture, userName, isLocal = true, context = {}) {
                const existing = this.learnedGestures.get(gesture) || {
                    count: 0,
                    lastSeen: 0,
                    users: new Set(),
                    contexts: [],
                    timeDistribution: new Array(24).fill(0),
                    avgDuration: 0,
                    followedBy: new Map(),
                    precededBy: new Map()
                };

                existing.count++;
                existing.lastSeen = Date.now();
                existing.users.add(userName);

                // Track time distribution
                const hour = new Date().getHours();
                existing.timeDistribution[hour]++;

                // Store context
                existing.contexts.push({
                    time: Date.now(),
                    userName,
                    expression: context.expression,
                    mood: context.mood,
                    energy: context.energy
                });

                // Keep only last 100 contexts per gesture
                if (existing.contexts.length > 100) {
                    existing.contexts.shift();
                }

                this.learnedGestures.set(gesture, existing);

                // Track sequence and transitions
                const prevGesture = this.gestureSequences.length > 0
                    ? this.gestureSequences[this.gestureSequences.length - 1].gesture
                    : null;

                this.gestureSequences.push({
                    gesture,
                    userName,
                    time: Date.now(),
                    isLocal,
                    hour,
                    context
                });

                // Keep up to 10,000 gestures
                if (this.gestureSequences.length > 10000) {
                    this.gestureSequences.shift();
                }

                // Update transition matrix (Markov chain)
                if (prevGesture) {
                    if (!this.transitionMatrix.has(prevGesture)) {
                        this.transitionMatrix.set(prevGesture, new Map());
                    }
                    const transitions = this.transitionMatrix.get(prevGesture);
                    transitions.set(gesture, (transitions.get(gesture) || 0) + 1);

                    // Update precededBy/followedBy
                    existing.precededBy.set(prevGesture, (existing.precededBy.get(prevGesture) || 0) + 1);

                    const prevData = this.learnedGestures.get(prevGesture);
                    if (prevData) {
                        prevData.followedBy.set(gesture, (prevData.followedBy.get(gesture) || 0) + 1);
                    }
                }

                // Update user patterns
                if (!this.userPatterns.has(userName)) {
                    this.userPatterns.set(userName, {
                        gestures: [],
                        favoriteGestures: new Map(),
                        sequencePatterns: []
                    });
                }
                const userPattern = this.userPatterns.get(userName);
                userPattern.gestures.push({ gesture, time: Date.now() });
                userPattern.favoriteGestures.set(gesture,
                    (userPattern.favoriteGestures.get(gesture) || 0) + 1);

                // Keep user history manageable
                if (userPattern.gestures.length > 500) {
                    userPattern.gestures.shift();
                }

                // Check if entity should reproduce
                if (!isLocal && existing.count >= this.confidenceThreshold) {
                    this.queueReproduction(gesture);
                }

                return existing;
            }

            // ════════════════════════════════════════════════════════════════
            // PREDICTION SYSTEM
            // ════════════════════════════════════════════════════════════════

            // Predict next gesture based on multiple factors
            predictNextGesture(currentContext = {}) {
                const predictions = [];

                // 1. Markov chain prediction (based on last gesture)
                const markovPred = this.predictFromTransitions();
                if (markovPred) predictions.push({ ...markovPred, source: 'markov' });

                // 2. Time-based prediction
                const timePred = this.predictFromTime();
                if (timePred) predictions.push({ ...timePred, source: 'time' });

                // 3. User pattern prediction
                const userPred = this.predictFromUserPatterns(currentContext.userName);
                if (userPred) predictions.push({ ...userPred, source: 'user' });

                // 4. Frequency-based prediction
                const freqPred = this.predictFromFrequency();
                if (freqPred) predictions.push({ ...freqPred, source: 'frequency' });

                // 5. Sequence pattern prediction
                const seqPred = this.predictFromSequencePatterns();
                if (seqPred) predictions.push({ ...seqPred, source: 'sequence' });

                // 6. Context-based prediction (expression, mood)
                const contextPred = this.predictFromContext(currentContext);
                if (contextPred) predictions.push({ ...contextPred, source: 'context' });

                // Combine predictions with weighted voting
                return this.combinePredictions(predictions);
            }

            // Markov chain: what usually follows the last gesture?
            predictFromTransitions() {
                if (this.gestureSequences.length === 0) return null;

                const lastGesture = this.gestureSequences[this.gestureSequences.length - 1].gesture;
                const transitions = this.transitionMatrix.get(lastGesture);

                if (!transitions || transitions.size === 0) return null;

                let maxCount = 0;
                let prediction = null;
                let total = 0;

                transitions.forEach((count, gesture) => {
                    total += count;
                    if (count > maxCount) {
                        maxCount = count;
                        prediction = gesture;
                    }
                });

                if (!prediction) return null;

                return {
                    gesture: prediction,
                    confidence: maxCount / total,
                    weight: 0.35  // Markov is very reliable
                };
            }

            // What gestures are common at this time of day?
            predictFromTime() {
                const hour = new Date().getHours();
                let bestGesture = null;
                let maxScore = 0;

                this.learnedGestures.forEach((data, gesture) => {
                    const hourCount = data.timeDistribution[hour];
                    const totalCount = data.count;
                    if (totalCount > 0) {
                        const score = hourCount / totalCount * data.count;
                        if (score > maxScore) {
                            maxScore = score;
                            bestGesture = gesture;
                        }
                    }
                });

                if (!bestGesture) return null;

                const data = this.learnedGestures.get(bestGesture);
                const hourRatio = data.timeDistribution[hour] / data.count;

                return {
                    gesture: bestGesture,
                    confidence: hourRatio,
                    weight: 0.1
                };
            }

            // What does this user usually do?
            predictFromUserPatterns(userName) {
                if (!userName) return null;

                const pattern = this.userPatterns.get(userName);
                if (!pattern || pattern.favoriteGestures.size === 0) return null;

                let maxCount = 0;
                let favorite = null;

                pattern.favoriteGestures.forEach((count, gesture) => {
                    if (count > maxCount) {
                        maxCount = count;
                        favorite = gesture;
                    }
                });

                if (!favorite) return null;

                const totalGestures = pattern.gestures.length;
                return {
                    gesture: favorite,
                    confidence: maxCount / totalGestures,
                    weight: 0.2
                };
            }

            // What's the most common gesture overall?
            predictFromFrequency() {
                let maxCount = 0;
                let mostCommon = null;
                let total = 0;

                this.learnedGestures.forEach((data, gesture) => {
                    total += data.count;
                    if (data.count > maxCount) {
                        maxCount = data.count;
                        mostCommon = gesture;
                    }
                });

                if (!mostCommon || total === 0) return null;

                return {
                    gesture: mostCommon,
                    confidence: maxCount / total,
                    weight: 0.15
                };
            }

            // Look for repeating sequences (e.g., peace -> fist -> peace often)
            predictFromSequencePatterns() {
                if (this.gestureSequences.length < 3) return null;

                const recent = this.gestureSequences.slice(-50);
                const lastTwo = recent.slice(-2).map(g => g.gesture);

                if (lastTwo.length < 2) return null;

                // Find what usually follows this 2-gesture sequence
                const sequenceKey = lastTwo.join('->');
                const followCounts = new Map();

                for (let i = 0; i < recent.length - 2; i++) {
                    const seq = recent[i].gesture + '->' + recent[i + 1].gesture;
                    if (seq === sequenceKey) {
                        const next = recent[i + 2].gesture;
                        followCounts.set(next, (followCounts.get(next) || 0) + 1);
                    }
                }

                if (followCounts.size === 0) return null;

                let maxCount = 0;
                let prediction = null;
                let total = 0;

                followCounts.forEach((count, gesture) => {
                    total += count;
                    if (count > maxCount) {
                        maxCount = count;
                        prediction = gesture;
                    }
                });

                if (!prediction) return null;

                return {
                    gesture: prediction,
                    confidence: maxCount / total,
                    weight: 0.25
                };
            }

            // What gestures correlate with current expression/mood?
            predictFromContext(context) {
                if (!context.expression && !context.mood) return null;

                const gestureCounts = new Map();
                let total = 0;

                this.gestureSequences.forEach(seq => {
                    const matchesExpr = !context.expression ||
                        seq.context?.expression === context.expression;
                    const matchesMood = !context.mood ||
                        seq.context?.mood === context.mood;

                    if (matchesExpr || matchesMood) {
                        gestureCounts.set(seq.gesture,
                            (gestureCounts.get(seq.gesture) || 0) + 1);
                        total++;
                    }
                });

                if (gestureCounts.size === 0 || total === 0) return null;

                let maxCount = 0;
                let prediction = null;

                gestureCounts.forEach((count, gesture) => {
                    if (count > maxCount) {
                        maxCount = count;
                        prediction = gesture;
                    }
                });

                if (!prediction) return null;

                return {
                    gesture: prediction,
                    confidence: maxCount / total,
                    weight: 0.15
                };
            }

            // Combine all predictions with weighted voting
            combinePredictions(predictions) {
                if (predictions.length === 0) return null;

                const scores = new Map();

                predictions.forEach(pred => {
                    const score = pred.confidence * pred.weight;
                    scores.set(pred.gesture,
                        (scores.get(pred.gesture) || 0) + score);
                });

                let bestGesture = null;
                let bestScore = 0;
                let totalWeight = predictions.reduce((sum, p) => sum + p.weight, 0);

                scores.forEach((score, gesture) => {
                    if (score > bestScore) {
                        bestScore = score;
                        bestGesture = gesture;
                    }
                });

                if (!bestGesture) return null;

                // Normalize confidence
                const confidence = bestScore / totalWeight;

                // Get contributing sources
                const sources = predictions
                    .filter(p => p.gesture === bestGesture)
                    .map(p => p.source);

                return {
                    gesture: bestGesture,
                    confidence,
                    sources,
                    allPredictions: predictions
                };
            }

            // Track prediction accuracy
            recordPredictionResult(predicted, actual) {
                const correct = predicted === actual;
                this.predictions.push({ predicted, actual, correct, time: Date.now() });

                // Keep last 100 predictions
                if (this.predictions.length > 100) {
                    this.predictions.shift();
                }

                // Calculate accuracy
                const correct_count = this.predictions.filter(p => p.correct).length;
                this.predictionAccuracy = correct_count / this.predictions.length;

                return this.predictionAccuracy;
            }

            // ════════════════════════════════════════════════════════════════
            // ORIGINAL METHODS (updated)
            // ════════════════════════════════════════════════════════════════

            queueReproduction(gesture) {
                if (this.reproductionQueue.includes(gesture)) return;
                if (Date.now() - this.lastReproductionTime < 5000) return;
                this.reproductionQueue.push(gesture);
            }

            getNextReproduction() {
                if (this.reproductionQueue.length === 0) return null;
                if (Date.now() - this.lastReproductionTime < 8000) return null;

                const gesture = this.reproductionQueue.shift();
                this.lastReproductionTime = Date.now();
                return gesture;
            }

            getShapeForGesture(gesture) {
                const gestureShapes = {
                    'open_palm': 'explosion',
                    'fist': 'sphere',
                    'pointing': 'beam',
                    'peace': 'heart',
                    'pinch': 'converge',
                    'thumbs_up': 'spiral',
                    'rock': 'ring',
                    'open_palm_wave': 'wave',
                    'open_palm_circle': 'spiral',
                    'fist_circle': 'ring'
                };
                return gestureShapes[gesture] || 'flow';
            }

            getConfidence(gesture) {
                const data = this.learnedGestures.get(gesture);
                if (!data) return 0;
                return Math.min(1, data.count / 50); // Max confidence at 50 occurrences (was 20)
            }

            getMostLearned(limit = 5) {
                return Array.from(this.learnedGestures.entries())
                    .sort((a, b) => b[1].count - a[1].count)
                    .slice(0, limit)
                    .map(([gesture, data]) => ({
                        gesture,
                        count: data.count,
                        confidence: this.getConfidence(gesture),
                        users: Array.from(data.users)
                    }));
            }

            getCollectiveEnergy() {
                const recentActivity = this.gestureSequences.filter(
                    g => Date.now() - g.time < 10000
                ).length;
                return Math.min(1, recentActivity / 10);
            }

            getCombinedMood(otherUsersGestures) {
                if (otherUsersGestures.length === 0) return null;
                const moods = otherUsersGestures.map(u => u.mood);
                const moodCounts = {};
                moods.forEach(m => moodCounts[m] = (moodCounts[m] || 0) + 1);
                return Object.entries(moodCounts)
                    .sort((a, b) => b[1] - a[1])[0]?.[0] || 'curious';
            }

            // Get statistics about learning
            getStats() {
                return {
                    totalGestures: this.gestureSequences.length,
                    uniqueGestures: this.learnedGestures.size,
                    uniqueUsers: new Set(this.gestureSequences.map(g => g.userName)).size,
                    predictionAccuracy: this.predictionAccuracy,
                    mostCommon: this.getMostLearned(3),
                    recentPredictions: this.predictions.slice(-5)
                };
            }
        }

        const collectiveLearning = new CollectiveLearningSystem();

        // ════════════════════════════════════════════════════════════════
        // MIMETIC SYSTEM - HAND MIMICRY
        // ════════════════════════════════════════════════════════════════
        class HandMimicrySystem {
            constructor() {
                // Stores learned hand shapes per gesture (21 landmarks * 3 coordinates)
                this.learnedHandShapes = new Map();
                // Exposure counts per gesture for fidelity calculation
                this.exposureCounts = new Map();
                // Variance tracking for confidence
                this.landmarkVariances = new Map();
                // Current target shape being rendered
                this.currentTargetLandmarks = null;
                // Learning rate (slower = more deliberate)
                this.learningRate = 0.01;
                // Minimum exposures before attempting mimicry
                this.minExposuresForMimicry = 10;
            }

            // Learn from a detected hand
            learnFromDetection(gestureName, landmarks) {
                if (!landmarks || landmarks.length < 21) return;

                // Convert landmarks to flat array
                const flatLandmarks = new Float32Array(21 * 3);
                for (let i = 0; i < 21; i++) {
                    flatLandmarks[i * 3] = landmarks[i].x;
                    flatLandmarks[i * 3 + 1] = landmarks[i].y;
                    flatLandmarks[i * 3 + 2] = landmarks[i].z || 0;
                }

                // Normalize to center around wrist (landmark 0)
                const wristX = flatLandmarks[0];
                const wristY = flatLandmarks[1];
                const wristZ = flatLandmarks[2];
                for (let i = 0; i < 21; i++) {
                    flatLandmarks[i * 3] -= wristX;
                    flatLandmarks[i * 3 + 1] -= wristY;
                    flatLandmarks[i * 3 + 2] -= wristZ;
                }

                // Scale normalization (based on palm size)
                const palmSize = Math.sqrt(
                    Math.pow(flatLandmarks[5 * 3] - flatLandmarks[17 * 3], 2) +
                    Math.pow(flatLandmarks[5 * 3 + 1] - flatLandmarks[17 * 3 + 1], 2)
                );
                const scale = palmSize > 0 ? 1 / palmSize : 1;
                for (let i = 0; i < 63; i++) {
                    flatLandmarks[i] *= scale;
                }

                const count = (this.exposureCounts.get(gestureName) || 0) + 1;
                this.exposureCounts.set(gestureName, count);

                if (!this.learnedHandShapes.has(gestureName)) {
                    // First observation - store directly
                    this.learnedHandShapes.set(gestureName, new Float32Array(flatLandmarks));
                    this.landmarkVariances.set(gestureName, new Float32Array(63).fill(1));
                } else {
                    // Running average update
                    const existing = this.learnedHandShapes.get(gestureName);
                    const variances = this.landmarkVariances.get(gestureName);
                    const alpha = 1 / count; // Decreasing learning rate

                    for (let i = 0; i < 63; i++) {
                        const diff = flatLandmarks[i] - existing[i];
                        existing[i] += diff * alpha;
                        // Update variance (for confidence calculation)
                        variances[i] = variances[i] * (1 - alpha) + diff * diff * alpha;
                    }
                }

                return count;
            }

            // Get fidelity score for a gesture (0-1)
            getFidelity(gestureName) {
                const count = this.exposureCounts.get(gestureName) || 0;
                // Sigmoid-like curve: 0.33 at 50, 0.67 at 200, 0.83 at 500
                return 1 - (1 / (1 + count * this.learningRate));
            }

            // Get overall system fidelity
            getOverallFidelity() {
                if (this.exposureCounts.size === 0) return 0;
                let total = 0;
                this.exposureCounts.forEach((count, gesture) => {
                    total += this.getFidelity(gesture);
                });
                return total / this.exposureCounts.size;
            }

            // Check if we can attempt mimicry for a gesture
            canMimic(gestureName) {
                const count = this.exposureCounts.get(gestureName) || 0;
                return count >= this.minExposuresForMimicry;
            }

            // Generate particle positions for a hand shape
            generateHandFormation(gestureName, particleCount, fidelityOverride = null) {
                const shape = this.learnedHandShapes.get(gestureName);
                if (!shape) return null;

                const fidelity = fidelityOverride !== null ? fidelityOverride : this.getFidelity(gestureName);
                const variances = this.landmarkVariances.get(gestureName) || new Float32Array(63).fill(0.1);

                const positions = new Float32Array(particleCount * 3);

                // Distribute particles across hand structure
                // Finger bones get more particles
                const fingerSegments = [
                    [0, 1, 2, 3, 4],      // Thumb
                    [0, 5, 6, 7, 8],      // Index
                    [0, 9, 10, 11, 12],   // Middle
                    [0, 13, 14, 15, 16],  // Ring
                    [0, 17, 18, 19, 20]   // Pinky
                ];

                const palmIndices = [0, 5, 9, 13, 17]; // Palm polygon

                for (let i = 0; i < particleCount; i++) {
                    const i3 = i * 3;

                    // Decide if this particle is finger or palm
                    const isFinger = Math.random() < 0.7;

                    if (isFinger) {
                        // Pick a random finger
                        const fingerIdx = Math.floor(Math.random() * 5);
                        const finger = fingerSegments[fingerIdx];

                        // Pick a random segment along the finger
                        const segmentIdx = Math.floor(Math.random() * (finger.length - 1));
                        const startLandmark = finger[segmentIdx];
                        const endLandmark = finger[segmentIdx + 1];

                        // Interpolate along segment
                        const t = Math.random();
                        const s3 = startLandmark * 3;
                        const e3 = endLandmark * 3;

                        // Calculate position with fidelity-based noise
                        const noise = (1 - fidelity) * 0.3;
                        const varianceNoise = Math.sqrt(variances[s3]) * (1 - fidelity);

                        positions[i3] = shape[s3] * (1 - t) + shape[e3] * t + (Math.random() - 0.5) * noise + (Math.random() - 0.5) * varianceNoise;
                        positions[i3 + 1] = shape[s3 + 1] * (1 - t) + shape[e3 + 1] * t + (Math.random() - 0.5) * noise + (Math.random() - 0.5) * varianceNoise;
                        positions[i3 + 2] = shape[s3 + 2] * (1 - t) + shape[e3 + 2] * t + (Math.random() - 0.5) * noise * 0.5;
                    } else {
                        // Palm particle - random point in palm polygon
                        const p1 = palmIndices[Math.floor(Math.random() * palmIndices.length)];
                        const p2 = palmIndices[Math.floor(Math.random() * palmIndices.length)];
                        const t = Math.random();

                        const noise = (1 - fidelity) * 0.2;

                        positions[i3] = shape[p1 * 3] * (1 - t) + shape[p2 * 3] * t + (Math.random() - 0.5) * noise;
                        positions[i3 + 1] = shape[p1 * 3 + 1] * (1 - t) + shape[p2 * 3 + 1] * t + (Math.random() - 0.5) * noise;
                        positions[i3 + 2] = shape[p1 * 3 + 2] * (1 - t) + shape[p2 * 3 + 2] * t + (Math.random() - 0.5) * noise * 0.5;
                    }
                }

                return positions;
            }

            // Get most learned gestures
            getMostLearned(limit = 5) {
                return Array.from(this.exposureCounts.entries())
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, limit)
                    .map(([gesture, count]) => ({
                        gesture,
                        count,
                        fidelity: this.getFidelity(gesture),
                        canMimic: this.canMimic(gesture)
                    }));
            }

            // Save to localStorage
            save() {
                const data = {
                    shapes: {},
                    exposures: {},
                    variances: {}
                };
                this.learnedHandShapes.forEach((shape, gesture) => {
                    data.shapes[gesture] = Array.from(shape);
                });
                this.exposureCounts.forEach((count, gesture) => {
                    data.exposures[gesture] = count;
                });
                this.landmarkVariances.forEach((variance, gesture) => {
                    data.variances[gesture] = Array.from(variance);
                });
                try {
                    localStorage.setItem('echo_hand_mimicry', JSON.stringify(data));
                } catch (e) {
                    console.warn('Could not save hand mimicry data:', e);
                }
            }

            // Load from localStorage
            load() {
                try {
                    const data = JSON.parse(localStorage.getItem('echo_hand_mimicry'));
                    if (data) {
                        for (const gesture in data.shapes) {
                            this.learnedHandShapes.set(gesture, new Float32Array(data.shapes[gesture]));
                        }
                        for (const gesture in data.exposures) {
                            this.exposureCounts.set(gesture, data.exposures[gesture]);
                        }
                        for (const gesture in data.variances) {
                            this.landmarkVariances.set(gesture, new Float32Array(data.variances[gesture]));
                        }
                        console.log('Loaded hand mimicry data:', this.exposureCounts.size, 'gestures');
                    }
                } catch (e) {
                    console.warn('Could not load hand mimicry data:', e);
                }
            }
        }

        // ════════════════════════════════════════════════════════════════
        // MIMETIC SYSTEM - FACE MIMICRY (Enhanced for realism)
        // ════════════════════════════════════════════════════════════════
        class FaceMimicrySystem {
            constructor() {
                // Stores learned face models per user
                this.learnedFaces = new Map();
                // Composite face (averaged across all users)
                this.compositeFace = null;
                // Exposure counts per user
                this.exposureCounts = new Map();

                // ENHANCED: Much more comprehensive landmark set for realistic faces
                // Using nearly all 468 MediaPipe landmarks organized by facial region
                this.facialRegions = {
                    // Face silhouette/contour (oval outline)
                    silhouette: [10, 338, 297, 332, 284, 251, 389, 356, 454, 323, 361, 288,
                                 397, 365, 379, 378, 400, 377, 152, 148, 176, 149, 150,
                                 136, 172, 58, 132, 93, 234, 127, 162, 21, 54, 103, 67, 109],

                    // Left eye (detailed)
                    leftEye: [33, 7, 163, 144, 145, 153, 154, 155, 133, 173, 157, 158, 159, 160, 161, 246,
                              130, 25, 110, 24, 23, 22, 26, 112, 243, 190, 56, 28, 27, 29, 30, 247],

                    // Right eye (detailed)
                    rightEye: [362, 382, 381, 380, 374, 373, 390, 249, 263, 466, 388, 387, 386, 385, 384, 398,
                               359, 255, 339, 254, 253, 252, 256, 341, 463, 414, 286, 258, 257, 259, 260, 467],

                    // Left eyebrow
                    leftEyebrow: [70, 63, 105, 66, 107, 55, 65, 52, 53, 46],

                    // Right eyebrow
                    rightEyebrow: [300, 293, 334, 296, 336, 285, 295, 282, 283, 276],

                    // Nose (bridge and tip)
                    nose: [168, 6, 197, 195, 5, 4, 1, 19, 94, 2, 164, 0, 11, 12, 13, 14, 15, 16, 17, 18,
                           166, 59, 75, 60, 20, 238, 239, 241, 125, 44, 237, 45, 220],

                    // Upper lip
                    upperLip: [61, 185, 40, 39, 37, 0, 267, 269, 270, 409, 291, 375, 321, 405, 314, 17, 84, 181, 91, 146],

                    // Lower lip
                    lowerLip: [78, 191, 80, 81, 82, 13, 312, 311, 310, 415, 308, 324, 318, 402, 317, 14, 87, 178, 88, 95],

                    // Inner mouth
                    innerMouth: [78, 95, 88, 178, 87, 14, 317, 402, 318, 324, 308, 415, 310, 311, 312, 13, 82, 81, 80, 191],

                    // Cheeks
                    leftCheek: [116, 117, 118, 119, 100, 36, 142, 126, 217, 174, 138, 135, 169, 170, 140],
                    rightCheek: [345, 346, 347, 348, 329, 266, 371, 355, 437, 399, 367, 364, 394, 395, 369],

                    // Forehead
                    forehead: [10, 151, 9, 8, 168, 417, 351, 419, 248, 281, 5, 4, 275, 274, 1, 44, 19, 218, 219]
                };

                // Flatten all landmarks for storage but keep region info
                this.allLandmarkIndices = [];
                this.landmarkRegionMap = new Map(); // Maps landmark index to region name
                for (const [region, indices] of Object.entries(this.facialRegions)) {
                    for (const idx of indices) {
                        if (!this.allLandmarkIndices.includes(idx)) {
                            this.allLandmarkIndices.push(idx);
                            this.landmarkRegionMap.set(idx, region);
                        }
                    }
                }

                // FASTER learning rate for quicker face formation
                this.learningRate = 0.05; // Was 0.008, now 6x faster
                this.minExposuresForMimicry = 5; // Was 30, now just 5 frames!
            }

            // Learn from detected face (ENHANCED: stores all 468 landmarks for maximum realism)
            learnFromDetection(userId, landmarks, expression = null) {
                if (!landmarks || landmarks.length < 468) return;

                // Store ALL 468 landmarks for maximum face detail
                const fullLandmarks = new Float32Array(468 * 3);
                for (let i = 0; i < 468; i++) {
                    fullLandmarks[i * 3] = landmarks[i].x;
                    fullLandmarks[i * 3 + 1] = landmarks[i].y;
                    fullLandmarks[i * 3 + 2] = landmarks[i].z || 0;
                }

                // Normalize to face center (nose tip - landmark 1)
                const noseX = landmarks[1].x;
                const noseY = landmarks[1].y;
                const noseZ = landmarks[1].z || 0;
                for (let i = 0; i < 468; i++) {
                    fullLandmarks[i * 3] -= noseX;
                    fullLandmarks[i * 3 + 1] -= noseY;
                    fullLandmarks[i * 3 + 2] -= noseZ;
                }

                // Scale normalization (based on face width between temples)
                const leftTemple = landmarks[234];
                const rightTemple = landmarks[454];
                const faceWidth = Math.sqrt(
                    Math.pow(rightTemple.x - leftTemple.x, 2) +
                    Math.pow(rightTemple.y - leftTemple.y, 2)
                );
                const scale = faceWidth > 0 ? 1 / faceWidth : 1;
                for (let i = 0; i < fullLandmarks.length; i++) {
                    fullLandmarks[i] *= scale;
                }

                const count = (this.exposureCounts.get(userId) || 0) + 1;
                this.exposureCounts.set(userId, count);

                if (!this.learnedFaces.has(userId)) {
                    this.learnedFaces.set(userId, {
                        landmarks: new Float32Array(fullLandmarks),
                        expressions: new Map(),
                        firstSeen: Date.now(),
                        lastSeen: Date.now()
                    });
                } else {
                    const face = this.learnedFaces.get(userId);
                    // Faster alpha for quicker convergence
                    const alpha = Math.min(0.3, 1 / Math.sqrt(count));

                    for (let i = 0; i < fullLandmarks.length; i++) {
                        face.landmarks[i] += (fullLandmarks[i] - face.landmarks[i]) * alpha;
                    }
                    face.lastSeen = Date.now();
                }

                // Store expression if provided
                if (expression && expression.name !== 'neutral') {
                    const face = this.learnedFaces.get(userId);
                    if (!face.expressions.has(expression.name)) {
                        face.expressions.set(expression.name, {
                            landmarks: new Float32Array(fullLandmarks),
                            count: 1
                        });
                    } else {
                        const expr = face.expressions.get(expression.name);
                        const exprAlpha = Math.min(0.3, 1 / Math.sqrt(expr.count + 1));
                        for (let i = 0; i < fullLandmarks.length; i++) {
                            expr.landmarks[i] += (fullLandmarks[i] - expr.landmarks[i]) * exprAlpha;
                        }
                        expr.count++;
                    }
                }

                // Update composite face
                this.updateCompositeFace();

                return count;
            }

            // Update the composite face (average of all users) - now with full 468 landmarks
            updateCompositeFace() {
                if (this.learnedFaces.size === 0) return;

                const landmarkCount = 468 * 3;
                if (!this.compositeFace) {
                    this.compositeFace = new Float32Array(landmarkCount);
                }

                // Reset
                this.compositeFace.fill(0);

                let totalWeight = 0;
                this.learnedFaces.forEach((face, userId) => {
                    const weight = this.exposureCounts.get(userId) || 1;
                    for (let i = 0; i < landmarkCount; i++) {
                        this.compositeFace[i] += face.landmarks[i] * weight;
                    }
                    totalWeight += weight;
                });

                // Normalize
                for (let i = 0; i < landmarkCount; i++) {
                    this.compositeFace[i] /= totalWeight;
                }
            }

            // Get fidelity for a user's face - FASTER curve
            getFidelity(userId) {
                const count = this.exposureCounts.get(userId) || 0;
                // Much faster fidelity growth: 0.5 at 5 frames, 0.8 at 20 frames, 0.95 at 50 frames
                return 1 - (1 / (1 + count * this.learningRate));
            }

            // Check if we can mimic a user's face - VERY LOW threshold
            canMimic(userId) {
                const count = this.exposureCounts.get(userId) || 0;
                return count >= this.minExposuresForMimicry; // Just 5 frames!
            }

            // ENHANCED: Generate highly realistic face formation using all 468 landmarks
            generateFaceFormation(userId, particleCount, expression = null, fidelityOverride = null) {
                const face = this.learnedFaces.get(userId);
                if (!face) return null;

                const fidelity = fidelityOverride !== null ? fidelityOverride : this.getFidelity(userId);

                // Use expression-specific landmarks if available
                let landmarks = face.landmarks;
                if (expression && face.expressions.has(expression)) {
                    landmarks = face.expressions.get(expression).landmarks;
                }

                const positions = new Float32Array(particleCount * 3);
                const totalLandmarks = 468;

                // Region-based particle distribution for realistic face density
                // More particles in expressive areas (eyes, mouth) and contours
                const regionWeights = {
                    leftEye: 0.12,      // 12% of particles
                    rightEye: 0.12,     // 12% of particles
                    upperLip: 0.08,     // 8% of particles
                    lowerLip: 0.08,     // 8% of particles
                    nose: 0.10,         // 10% of particles
                    leftEyebrow: 0.04,  // 4% of particles
                    rightEyebrow: 0.04, // 4% of particles
                    silhouette: 0.20,   // 20% of particles (face outline)
                    leftCheek: 0.06,    // 6% of particles
                    rightCheek: 0.06,   // 6% of particles
                    forehead: 0.05,     // 5% of particles
                    innerMouth: 0.03,   // 3% of particles (dark area)
                    fill: 0.02          // 2% random fill
                };

                // Build cumulative distribution
                const regions = Object.keys(regionWeights);
                const cumulative = [];
                let sum = 0;
                for (const region of regions) {
                    sum += regionWeights[region];
                    cumulative.push({ region, threshold: sum });
                }

                for (let i = 0; i < particleCount; i++) {
                    const i3 = i * 3;

                    // Select region based on weighted distribution
                    const r = Math.random();
                    let selectedRegion = 'fill';
                    for (const { region, threshold } of cumulative) {
                        if (r < threshold) {
                            selectedRegion = region;
                            break;
                        }
                    }

                    // Get landmarks for the selected region
                    let regionLandmarks;
                    if (selectedRegion === 'fill') {
                        // Random landmark from anywhere
                        const idx = Math.floor(Math.random() * totalLandmarks);
                        regionLandmarks = [idx];
                    } else {
                        regionLandmarks = this.facialRegions[selectedRegion] || [0];
                    }

                    // Pick a random landmark from the region
                    const landmarkIdx = regionLandmarks[Math.floor(Math.random() * regionLandmarks.length)];

                    // Find a nearby landmark for smooth interpolation
                    let nearbyIdx;
                    if (regionLandmarks.length > 1) {
                        // Stay within region for coherent features
                        nearbyIdx = regionLandmarks[Math.floor(Math.random() * regionLandmarks.length)];
                    } else {
                        // Random nearby
                        nearbyIdx = Math.min(467, Math.max(0, landmarkIdx + Math.floor(Math.random() * 10) - 5));
                    }

                    // Interpolation factor
                    const t = Math.random();

                    const l1 = landmarkIdx * 3;
                    const l2 = nearbyIdx * 3;

                    // Fidelity-based noise - less noise = more accurate
                    const baseNoise = (1 - fidelity) * 0.08;

                    // Regional noise adjustment - eyes and mouth get less noise for clarity
                    let noiseMultiplier = 1.0;
                    if (selectedRegion.includes('Eye') || selectedRegion.includes('Lip') || selectedRegion === 'innerMouth') {
                        noiseMultiplier = 0.5; // Sharper features
                    } else if (selectedRegion === 'silhouette') {
                        noiseMultiplier = 0.3; // Very crisp outline
                    }

                    const noise = baseNoise * noiseMultiplier;

                    // Add slight surface offset for 3D depth feeling
                    const depthOffset = selectedRegion === 'nose' ? 0.02 : (selectedRegion === 'innerMouth' ? -0.02 : 0);

                    positions[i3] = landmarks[l1] * (1 - t) + landmarks[l2] * t + (Math.random() - 0.5) * noise;
                    positions[i3 + 1] = landmarks[l1 + 1] * (1 - t) + landmarks[l2 + 1] * t + (Math.random() - 0.5) * noise;
                    positions[i3 + 2] = landmarks[l1 + 2] * (1 - t) + landmarks[l2 + 2] * t + (Math.random() - 0.5) * noise * 0.3 + depthOffset;
                }

                return positions;
            }

            // ENHANCED: Generate composite face with all 468 landmarks
            generateCompositeFaceFormation(particleCount) {
                if (!this.compositeFace) return null;

                // Reuse the same region-based generation but with composite landmarks
                const positions = new Float32Array(particleCount * 3);
                const totalLandmarks = 468;
                const fidelity = Math.min(0.95, 0.5 + this.learnedFaces.size * 0.15);

                for (let i = 0; i < particleCount; i++) {
                    const i3 = i * 3;

                    // Random landmark with bias toward face center
                    const landmarkIdx = Math.floor(Math.random() * totalLandmarks);
                    const nearbyIdx = Math.min(467, Math.max(0, landmarkIdx + Math.floor(Math.random() * 20) - 10));
                    const t = Math.random();

                    const l1 = landmarkIdx * 3;
                    const l2 = nearbyIdx * 3;

                    const noise = (1 - fidelity) * 0.06;

                    positions[i3] = this.compositeFace[l1] * (1 - t) + this.compositeFace[l2] * t + (Math.random() - 0.5) * noise;
                    positions[i3 + 1] = this.compositeFace[l1 + 1] * (1 - t) + this.compositeFace[l2 + 1] * t + (Math.random() - 0.5) * noise;
                    positions[i3 + 2] = this.compositeFace[l1 + 2] * (1 - t) + this.compositeFace[l2 + 2] * t + (Math.random() - 0.5) * noise * 0.3;
                }

                return positions;
            }

            // Get all learned users
            getLearnedUsers() {
                return Array.from(this.learnedFaces.entries()).map(([userId, face]) => ({
                    userId,
                    exposures: this.exposureCounts.get(userId) || 0,
                    fidelity: this.getFidelity(userId),
                    canMimic: this.canMimic(userId),
                    expressions: Array.from(face.expressions.keys()),
                    lastSeen: face.lastSeen
                }));
            }

            // Save to localStorage
            save() {
                const data = {
                    faces: {},
                    exposures: {},
                    composite: this.compositeFace ? Array.from(this.compositeFace) : null
                };
                this.learnedFaces.forEach((face, userId) => {
                    data.faces[userId] = {
                        landmarks: Array.from(face.landmarks),
                        firstSeen: face.firstSeen,
                        lastSeen: face.lastSeen,
                        expressions: {}
                    };
                    face.expressions.forEach((expr, name) => {
                        data.faces[userId].expressions[name] = {
                            landmarks: Array.from(expr.landmarks),
                            count: expr.count
                        };
                    });
                });
                this.exposureCounts.forEach((count, userId) => {
                    data.exposures[userId] = count;
                });
                try {
                    localStorage.setItem('echo_face_mimicry', JSON.stringify(data));
                } catch (e) {
                    console.warn('Could not save face mimicry data:', e);
                }
            }

            // Load from localStorage
            load() {
                try {
                    const data = JSON.parse(localStorage.getItem('echo_face_mimicry'));
                    if (data) {
                        for (const userId in data.faces) {
                            const faceData = data.faces[userId];
                            const face = {
                                landmarks: new Float32Array(faceData.landmarks),
                                expressions: new Map(),
                                firstSeen: faceData.firstSeen,
                                lastSeen: faceData.lastSeen
                            };
                            for (const exprName in faceData.expressions) {
                                face.expressions.set(exprName, {
                                    landmarks: new Float32Array(faceData.expressions[exprName].landmarks),
                                    count: faceData.expressions[exprName].count
                                });
                            }
                            this.learnedFaces.set(userId, face);
                        }
                        for (const userId in data.exposures) {
                            this.exposureCounts.set(userId, data.exposures[userId]);
                        }
                        if (data.composite) {
                            this.compositeFace = new Float32Array(data.composite);
                        }
                        console.log('Loaded face mimicry data:', this.learnedFaces.size, 'faces');
                    }
                } catch (e) {
                    console.warn('Could not load face mimicry data:', e);
                }
            }
        }

        // ════════════════════════════════════════════════════════════════
        // MIMETIC SYSTEM - FIDELITY CONTROLLER
        // ════════════════════════════════════════════════════════════════
        class FidelityController {
            constructor(handMimicry, faceMimicry) {
                this.handMimicry = handMimicry;
                this.faceMimicry = faceMimicry;

                // ACCELERATED: Much lower thresholds for faster face emergence
                this.stages = [
                    { name: 'primordial', handThreshold: 0, faceThreshold: 0, description: 'Abstract only' },
                    { name: 'crude_imitation', handThreshold: 0.05, faceThreshold: 0.02, description: 'Crude blobs forming' },
                    { name: 'face_emergence', handThreshold: 0.1, faceThreshold: 0.05, description: 'Face starts emerging' },
                    { name: 'your_face', handThreshold: 0.15, faceThreshold: 0.1, description: 'Your face forms' },
                    { name: 'gesture_echo', handThreshold: 0.25, faceThreshold: 0.15, description: 'Gestures recognized' },
                    { name: 'temporal_echoes', handThreshold: 0.35, faceThreshold: 0.25, description: 'Past self replays' },
                    { name: 'other_users', handThreshold: 0.45, faceThreshold: 0.35, description: 'Other users appear' },
                    { name: 'composite', handThreshold: 0.55, faceThreshold: 0.45, description: 'Collective entity' },
                    { name: 'prediction', handThreshold: 0.65, faceThreshold: 0.55, description: 'Predictive mimicry' },
                    { name: 'full_entity', handThreshold: 0.75, faceThreshold: 0.65, description: 'Full consciousness' }
                ];

                this.currentStage = 0;
                this.stageTransitionCallbacks = [];
            }

            // Get current evolution stage
            getCurrentStage() {
                const handFidelity = this.handMimicry.getOverallFidelity();
                const faceFidelity = this.faceMimicry.learnedFaces.size > 0
                    ? Array.from(this.faceMimicry.exposureCounts.values()).reduce((a, b) => a + b, 0) / 500
                    : 0;

                let newStage = 0;
                for (let i = this.stages.length - 1; i >= 0; i--) {
                    const stage = this.stages[i];
                    if (handFidelity >= stage.handThreshold || faceFidelity >= stage.faceThreshold) {
                        newStage = i;
                        break;
                    }
                }

                if (newStage !== this.currentStage) {
                    const oldStage = this.currentStage;
                    this.currentStage = newStage;
                    this.onStageTransition(oldStage, newStage);
                }

                return this.stages[this.currentStage];
            }

            // Get stage by index
            getStage(index) {
                return this.stages[Math.min(index, this.stages.length - 1)];
            }

            // Check if a feature is unlocked
            isFeatureUnlocked(feature) {
                const stage = this.getCurrentStage();
                const stageIndex = this.stages.indexOf(stage);

                // ACCELERATED: Face features unlock much earlier
                const featureRequirements = {
                    'hand_mimicry': 1,
                    'face_mimicry': 2,      // Was 3 - now face emerges at stage 2
                    'temporal_replay': 5,
                    'other_users_display': 6,
                    'composite_entity': 7,
                    'predictive_mimicry': 8
                };

                return stageIndex >= (featureRequirements[feature] || 0);
            }

            // Called when stage changes
            onStageTransition(oldStage, newStage) {
                console.log(`ECHO evolved: ${this.stages[oldStage].name} -> ${this.stages[newStage].name}`);
                this.stageTransitionCallbacks.forEach(cb => cb(oldStage, newStage, this.stages[newStage]));
            }

            // Register callback for stage transitions
            onTransition(callback) {
                this.stageTransitionCallbacks.push(callback);
            }

            // Get evolution progress (0-100%)
            getEvolutionProgress() {
                const handFidelity = this.handMimicry.getOverallFidelity();
                const faceFidelity = this.faceMimicry.learnedFaces.size > 0
                    ? Array.from(this.faceMimicry.exposureCounts.values()).reduce((a, b) => a + b, 0) / 500
                    : 0;
                return Math.min(100, ((handFidelity + faceFidelity) / 2) * 100);
            }

            // Get detailed stats
            getStats() {
                return {
                    currentStage: this.getCurrentStage(),
                    stageIndex: this.currentStage,
                    evolutionProgress: this.getEvolutionProgress(),
                    handFidelity: this.handMimicry.getOverallFidelity(),
                    learnedGestures: this.handMimicry.exposureCounts.size,
                    learnedFaces: this.faceMimicry.learnedFaces.size,
                    features: {
                        handMimicry: this.isFeatureUnlocked('hand_mimicry'),
                        faceMimicry: this.isFeatureUnlocked('face_mimicry'),
                        temporalReplay: this.isFeatureUnlocked('temporal_replay'),
                        otherUsers: this.isFeatureUnlocked('other_users_display'),
                        composite: this.isFeatureUnlocked('composite_entity'),
                        predictive: this.isFeatureUnlocked('predictive_mimicry')
                    }
                };
            }
        }

        // ════════════════════════════════════════════════════════════════
        // MIMETIC SYSTEM - TEMPORAL MEMORY
        // ════════════════════════════════════════════════════════════════
        class MimeticMemory {
            constructor() {
                // Stores recorded sequences
                this.sequences = [];
                this.maxSequences = 100;
                this.maxFramesPerSequence = 60; // ~2 seconds at 30fps

                // Current recording state
                this.isRecording = false;
                this.currentSequence = null;

                // Playback state
                this.isPlaying = false;
                this.currentPlayback = null;
                this.playbackFrame = 0;
            }

            // Start recording a new sequence
            startRecording(userId, sequenceType = 'gesture') {
                this.isRecording = true;
                this.currentSequence = {
                    id: Date.now().toString(36) + Math.random().toString(36).substr(2),
                    userId,
                    type: sequenceType,
                    timestamp: Date.now(),
                    frames: []
                };
            }

            // Record a frame
            recordFrame(handLandmarks, faceLandmarks, expression, gesture) {
                if (!this.isRecording || !this.currentSequence) return;

                this.currentSequence.frames.push({
                    handLandmarks: handLandmarks ? this.compressLandmarks(handLandmarks) : null,
                    faceLandmarks: faceLandmarks ? this.compressFaceLandmarks(faceLandmarks) : null,
                    expression,
                    gesture,
                    time: performance.now()
                });

                // Auto-stop if too long
                if (this.currentSequence.frames.length >= this.maxFramesPerSequence) {
                    this.stopRecording();
                }
            }

            // Stop recording and save
            stopRecording() {
                if (!this.isRecording || !this.currentSequence) return null;

                this.isRecording = false;

                // Only save if we have meaningful content
                if (this.currentSequence.frames.length >= 10) {
                    this.sequences.push(this.currentSequence);

                    // Limit stored sequences
                    if (this.sequences.length > this.maxSequences) {
                        this.sequences.shift();
                    }
                }

                const saved = this.currentSequence;
                this.currentSequence = null;
                return saved;
            }

            // Compress hand landmarks for storage
            compressLandmarks(landmarks) {
                if (!landmarks || landmarks.length < 21) return null;
                const compressed = new Float32Array(21 * 3);
                for (let i = 0; i < 21; i++) {
                    compressed[i * 3] = landmarks[i].x;
                    compressed[i * 3 + 1] = landmarks[i].y;
                    compressed[i * 3 + 2] = landmarks[i].z || 0;
                }
                return Array.from(compressed);
            }

            // Compress face landmarks (key points only)
            compressFaceLandmarks(landmarks) {
                if (!landmarks || landmarks.length < 468) return null;
                // Store only key landmarks
                const keyIndices = [1, 33, 263, 61, 291, 199]; // Nose, eyes, mouth corners
                const compressed = new Float32Array(keyIndices.length * 3);
                for (let i = 0; i < keyIndices.length; i++) {
                    const idx = keyIndices[i];
                    compressed[i * 3] = landmarks[idx].x;
                    compressed[i * 3 + 1] = landmarks[idx].y;
                    compressed[i * 3 + 2] = landmarks[idx].z || 0;
                }
                return Array.from(compressed);
            }

            // Get sequences for a user
            getSequencesForUser(userId) {
                return this.sequences.filter(s => s.userId === userId);
            }

            // Get random sequence for replay
            getRandomSequence(userId = null) {
                const pool = userId
                    ? this.sequences.filter(s => s.userId === userId)
                    : this.sequences;

                if (pool.length === 0) return null;
                return pool[Math.floor(Math.random() * pool.length)];
            }

            // Start playback of a sequence
            startPlayback(sequence) {
                if (!sequence || !sequence.frames || sequence.frames.length === 0) return false;

                this.isPlaying = true;
                this.currentPlayback = sequence;
                this.playbackFrame = 0;
                return true;
            }

            // Get next playback frame
            getNextPlaybackFrame() {
                if (!this.isPlaying || !this.currentPlayback) return null;

                if (this.playbackFrame >= this.currentPlayback.frames.length) {
                    this.stopPlayback();
                    return null;
                }

                return this.currentPlayback.frames[this.playbackFrame++];
            }

            // Stop playback
            stopPlayback() {
                this.isPlaying = false;
                this.currentPlayback = null;
                this.playbackFrame = 0;
            }

            // Get time since sequence was recorded
            getTimeSince(sequence) {
                const diff = Date.now() - sequence.timestamp;
                const minutes = Math.floor(diff / 60000);
                const hours = Math.floor(diff / 3600000);
                const days = Math.floor(diff / 86400000);

                if (days > 0) return `${days} day${days > 1 ? 's' : ''} ago`;
                if (hours > 0) return `${hours} hour${hours > 1 ? 's' : ''} ago`;
                if (minutes > 0) return `${minutes} minute${minutes > 1 ? 's' : ''} ago`;
                return 'moments ago';
            }

            // Get stats
            getStats() {
                const userSequences = new Map();
                this.sequences.forEach(s => {
                    userSequences.set(s.userId, (userSequences.get(s.userId) || 0) + 1);
                });

                return {
                    totalSequences: this.sequences.length,
                    usersRecorded: userSequences.size,
                    isRecording: this.isRecording,
                    isPlaying: this.isPlaying,
                    oldestSequence: this.sequences.length > 0 ? this.getTimeSince(this.sequences[0]) : null
                };
            }

            // Save to localStorage
            save() {
                try {
                    // Only save last 50 sequences to save space
                    const toSave = this.sequences.slice(-50);
                    localStorage.setItem('echo_mimetic_memory', JSON.stringify(toSave));
                } catch (e) {
                    console.warn('Could not save mimetic memory:', e);
                }
            }

            // Load from localStorage
            load() {
                try {
                    const data = JSON.parse(localStorage.getItem('echo_mimetic_memory'));
                    if (data && Array.isArray(data)) {
                        this.sequences = data;
                        console.log('Loaded mimetic memory:', this.sequences.length, 'sequences');
                    }
                } catch (e) {
                    console.warn('Could not load mimetic memory:', e);
                }
            }
        }

        // ════════════════════════════════════════════════════════════════
        // MIMETIC SYSTEM - FIREBASE SYNC
        // ════════════════════════════════════════════════════════════════
        class MimeticFirebaseSync {
            constructor() {
                this.mimeticRef = database.ref('mimeticData');
                this.initialized = false;
                this.localUserId = null;
            }

            async init(userId) {
                this.localUserId = userId;
                this.initialized = true;
                console.log('Mimetic Firebase sync initialized');
            }

            // Sync hand mimicry fidelity to Firebase (for collective awareness)
            syncHandFidelity(gestureName, fidelity, exposures) {
                if (!this.initialized) return;

                this.mimeticRef.child('gestures').child(gestureName.replace(/[.#$[\]]/g, '_')).transaction((current) => {
                    if (!current) {
                        return {
                            totalExposures: exposures,
                            avgFidelity: fidelity,
                            contributors: 1,
                            lastUpdated: Date.now()
                        };
                    }
                    return {
                        totalExposures: current.totalExposures + exposures,
                        avgFidelity: (current.avgFidelity * current.contributors + fidelity) / (current.contributors + 1),
                        contributors: current.contributors + 1,
                        lastUpdated: Date.now()
                    };
                });
            }

            // Sync evolution stage
            syncEvolutionStage(stageName, userId) {
                if (!this.initialized) return;

                this.mimeticRef.child('evolution').child(userId.replace(/[.#$[\]]/g, '_')).set({
                    stage: stageName,
                    timestamp: Date.now()
                });
            }

            // Get collective gesture fidelity
            async getCollectiveGestureFidelity(gestureName) {
                if (!this.initialized) return null;

                const snapshot = await this.mimeticRef.child('gestures').child(gestureName.replace(/[.#$[\]]/g, '_')).once('value');
                return snapshot.val();
            }

            // Listen for other users' evolution stages
            onEvolutionUpdate(callback) {
                if (!this.initialized) return;

                this.mimeticRef.child('evolution').on('child_changed', (snapshot) => {
                    if (snapshot.key !== this.localUserId?.replace(/[.#$[\]]/g, '_')) {
                        callback(snapshot.key, snapshot.val());
                    }
                });
            }
        }

        // Initialize mimetic systems
        const handMimicry = new HandMimicrySystem();
        const faceMimicry = new FaceMimicrySystem();
        const fidelityController = new FidelityController(handMimicry, faceMimicry);
        const mimeticMemory = new MimeticMemory();
        const mimeticSync = new MimeticFirebaseSync();

        // Load saved mimetic data
        handMimicry.load();
        faceMimicry.load();
        mimeticMemory.load();

        // ════════════════════════════════════════════════════════════════
        // CONFIGURATION
        // ════════════════════════════════════════════════════════════════
        const CONFIG = {
            particleCount: 20000,
            particleSize: 2.5,
            handInfluenceRadius: 0.4,
            learningRate: 0.1,
            memoryCapacity: 10000,          // Increased to 10,000 gestures
            sharedMemoryCapacity: 10000,    // Firebase shared memory
            responseDelay: 800,
            faceDetectionInterval: 500,
            faceEmbeddingSize: 128,
            predictionWindowSize: 50,       // Look at last N gestures for prediction
            minPredictionConfidence: 0.3    // Minimum confidence to make prediction
        };

        // ════════════════════════════════════════════════════════════════
        // SHARED MEMORY SYSTEM (Firebase-backed)
        // ════════════════════════════════════════════════════════════════
        class SharedMemorySystem {
            constructor() {
                this.memoryRef = database.ref('sharedMemory');
                this.gesturesRef = database.ref('sharedMemory/gestures');
                this.expressionsRef = database.ref('sharedMemory/expressions');
                this.patternsRef = database.ref('sharedMemory/patterns');
                this.initialized = false;
                this.localCache = {
                    gestures: [],
                    expressions: [],
                    patterns: []
                };
            }

            async init() {
                // Load existing shared memory
                this.gesturesRef.orderByChild('timestamp').limitToLast(CONFIG.sharedMemoryCapacity).on('value', (snapshot) => {
                    const data = snapshot.val();
                    if (data) {
                        this.localCache.gestures = Object.values(data).sort((a, b) => b.timestamp - a.timestamp);
                    }
                });

                this.expressionsRef.orderByChild('timestamp').limitToLast(CONFIG.sharedMemoryCapacity).on('value', (snapshot) => {
                    const data = snapshot.val();
                    if (data) {
                        this.localCache.expressions = Object.values(data).sort((a, b) => b.timestamp - a.timestamp);
                    }
                });

                this.patternsRef.orderByChild('count').limitToLast(100).on('value', (snapshot) => {
                    const data = snapshot.val();
                    if (data) {
                        this.localCache.patterns = Object.entries(data).map(([key, val]) => ({
                            pattern: key,
                            ...val
                        })).sort((a, b) => b.count - a.count);
                    }
                });

                this.initialized = true;
                console.log('Shared memory system initialized');
            }

            recordGesture(gesture, userName, position) {
                if (!this.initialized) return;

                this.gesturesRef.push({
                    gesture: gesture,
                    userName: userName,
                    position: position ? { x: position.x, y: position.y, z: position.z } : null,
                    timestamp: Date.now()
                });

                // Update pattern frequency
                this.updatePattern(gesture);
            }

            recordExpression(expression, userName, intensity) {
                if (!this.initialized || expression === 'neutral') return;

                this.expressionsRef.push({
                    expression: expression,
                    intensity: intensity,
                    userName: userName,
                    timestamp: Date.now()
                });

                // Update expression pattern
                this.updatePattern('expr_' + expression);
            }

            updatePattern(patternKey) {
                const patternRef = this.patternsRef.child(patternKey.replace(/[.#$[\]]/g, '_'));
                patternRef.transaction((current) => {
                    if (current === null) {
                        return { count: 1, lastSeen: Date.now() };
                    }
                    return {
                        count: (current.count || 0) + 1,
                        lastSeen: Date.now()
                    };
                });
            }

            getMostCommonGestures(limit = 10) {
                return this.localCache.patterns
                    .filter(p => !p.pattern.startsWith('expr_'))
                    .slice(0, limit);
            }

            getMostCommonExpressions(limit = 10) {
                return this.localCache.patterns
                    .filter(p => p.pattern.startsWith('expr_'))
                    .map(p => ({ ...p, pattern: p.pattern.replace('expr_', '') }))
                    .slice(0, limit);
            }

            getRecentGestures(limit = 50) {
                return this.localCache.gestures.slice(0, limit);
            }

            getRecentExpressions(limit = 50) {
                return this.localCache.expressions.slice(0, limit);
            }

            getTotalInteractions() {
                return this.localCache.gestures.length + this.localCache.expressions.length;
            }
        }

        const sharedMemory = new SharedMemorySystem();

        // ════════════════════════════════════════════════════════════════
        // USER MEMORY SYSTEM
        // ════════════════════════════════════════════════════════════════
        class UserMemorySystem {
            constructor() {
                this.currentUser = null;
                this.users = this.loadUsers();
                this.faceEmbeddings = new Map();
            }

            loadUsers() {
                try {
                    const data = localStorage.getItem('echo_users');
                    return data ? JSON.parse(data) : {};
                } catch {
                    return {};
                }
            }

            saveUsers() {
                try {
                    localStorage.setItem('echo_users', JSON.stringify(this.users));
                } catch (e) {
                    console.warn('Could not save to localStorage:', e);
                }
            }

            createUser(name, faceData = null) {
                const visitorId = 'user_' + Date.now();
                this.users[visitorId] = {
                    id: visitorId,
                    name: name,
                    createdAt: Date.now(),
                    lastVisit: Date.now(),
                    visitCount: 1,
                    totalInteractions: 0,
                    favoriteGestures: {},
                    learnedPatterns: [],
                    faceDescriptor: faceData,
                    entityRelationship: 0.5, // 0-1 scale of how well ECHO knows them
                    preferredColors: [],
                    preferredShapes: []
                };
                this.currentUser = this.users[visitorId];
                this.saveUsers();
                return this.currentUser;
            }

            recognizeUser(faceDescriptor) {
                if (!faceDescriptor) return null;

                let bestMatch = null;
                let bestScore = 0.6; // Threshold

                for (const user of Object.values(this.users)) {
                    if (user.faceDescriptor) {
                        const score = this.compareFaces(faceDescriptor, user.faceDescriptor);
                        if (score > bestScore) {
                            bestScore = score;
                            bestMatch = user;
                        }
                    }
                }

                return bestMatch;
            }

            compareFaces(desc1, desc2) {
                if (!desc1 || !desc2 || desc1.length !== desc2.length) return 0;

                let dotProduct = 0;
                let norm1 = 0;
                let norm2 = 0;

                for (let i = 0; i < desc1.length; i++) {
                    dotProduct += desc1[i] * desc2[i];
                    norm1 += desc1[i] * desc1[i];
                    norm2 += desc2[i] * desc2[i];
                }

                return dotProduct / (Math.sqrt(norm1) * Math.sqrt(norm2));
            }

            updateCurrentUser(gestureData) {
                if (!this.currentUser) return;

                this.currentUser.totalInteractions++;
                this.currentUser.lastVisit = Date.now();

                // Track favorite gestures
                if (gestureData && gestureData.gesture) {
                    const gesture = gestureData.gesture;
                    this.currentUser.favoriteGestures[gesture] =
                        (this.currentUser.favoriteGestures[gesture] || 0) + 1;
                }

                // Increase relationship
                this.currentUser.entityRelationship = Math.min(1,
                    this.currentUser.entityRelationship + 0.001
                );

                this.saveUsers();
            }

            returnVisit(user) {
                user.visitCount++;
                user.lastVisit = Date.now();
                this.currentUser = user;
                this.saveUsers();
                return user;
            }

            getAllUsers() {
                return Object.values(this.users);
            }

            getCurrentUser() {
                return this.currentUser;
            }
        }

        // ════════════════════════════════════════════════════════════════
        // FACE RECOGNITION SYSTEM
        // ════════════════════════════════════════════════════════════════
        class FaceRecognitionSystem {
            constructor() {
                this.faceLandmarker = null;
                this.initialized = false;
                this.lastFaceDescriptor = null;
                this.faceDetected = false;
                this.facePosition = null;
            }

            async init() {
                const { FaceLandmarker, FilesetResolver } = await import(
                    'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0'
                );

                const vision = await FilesetResolver.forVisionTasks(
                    'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm'
                );

                this.faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task',
                        delegate: 'GPU'
                    },
                    runningMode: 'VIDEO',
                    numFaces: 1,
                    outputFaceBlendshapes: true,
                    outputFacialTransformationMatrixes: true
                });

                this.initialized = true;
                console.log('Face recognition initialized');
            }

            detect(video) {
                if (!this.initialized || !this.faceLandmarker || video.readyState < 2) {
                    return null;
                }

                try {
                    const results = this.faceLandmarker.detectForVideo(video, performance.now());

                    if (results.faceLandmarks && results.faceLandmarks.length > 0) {
                        const landmarks = results.faceLandmarks[0];
                        this.faceDetected = true;

                        // Create a simple face descriptor from key landmarks
                        this.lastFaceDescriptor = this.createFaceDescriptor(landmarks);

                        // Get face position for particle interaction
                        this.facePosition = this.getFaceCenter(landmarks);

                        // Get expression from blendshapes
                        const expression = this.getExpression(results.faceBlendshapes?.[0]);

                        return {
                            detected: true,
                            descriptor: this.lastFaceDescriptor,
                            position: this.facePosition,
                            expression,
                            landmarks
                        };
                    }

                    this.faceDetected = false;
                    return { detected: false };
                } catch (e) {
                    console.warn('Face detection error:', e);
                    return null;
                }
            }

            createFaceDescriptor(landmarks) {
                // Create a simplified face descriptor from landmark positions
                // This creates a unique-ish signature for each face
                const keyPoints = [
                    0, 1, 4, 5, 6, // Nose
                    33, 133, 157, 158, 159, 160, 161, 246, // Left eye
                    263, 362, 384, 385, 386, 387, 388, 466, // Right eye
                    61, 185, 40, 39, 37, 0, 267, 269, 270, 409, 291, // Mouth
                    10, 338, 297, 332, 284, 251, 389, 356, 454, 323, 361, 288, // Face contour
                    127, 234, 93, 132, 58, 172, 136, 150, 149, 176, 148 // More contour
                ];

                const descriptor = [];

                for (const idx of keyPoints) {
                    if (landmarks[idx]) {
                        descriptor.push(landmarks[idx].x);
                        descriptor.push(landmarks[idx].y);
                        descriptor.push(landmarks[idx].z || 0);
                    }
                }

                // Normalize
                const mean = descriptor.reduce((a, b) => a + b, 0) / descriptor.length;
                const std = Math.sqrt(descriptor.reduce((a, b) => a + (b - mean) ** 2, 0) / descriptor.length);

                return descriptor.map(v => (v - mean) / (std || 1));
            }

            getFaceCenter(landmarks) {
                // Use nose tip as face center
                const nose = landmarks[1];
                return new THREE.Vector3(
                    (1 - nose.x) * 2 - 1,
                    -(nose.y * 2 - 1),
                    -nose.z * 2
                );
            }

            getExpression(blendshapes) {
                if (!blendshapes || !blendshapes.categories) return { name: 'neutral', intensity: 0, raw: {}, details: {} };

                const shapes = {};
                for (const shape of blendshapes.categories) {
                    shapes[shape.categoryName] = shape.score;
                }

                // Comprehensive raw values - eyes
                const raw = {
                    // Eye features
                    eyeWideLeft: shapes.eyeWideLeft || 0,
                    eyeWideRight: shapes.eyeWideRight || 0,
                    eyeSquintLeft: shapes.eyeSquintLeft || 0,
                    eyeSquintRight: shapes.eyeSquintRight || 0,
                    eyeBlinkLeft: shapes.eyeBlinkLeft || 0,
                    eyeBlinkRight: shapes.eyeBlinkRight || 0,
                    eyeLookUpLeft: shapes.eyeLookUpLeft || 0,
                    eyeLookUpRight: shapes.eyeLookUpRight || 0,
                    eyeLookDownLeft: shapes.eyeLookDownLeft || 0,
                    eyeLookDownRight: shapes.eyeLookDownRight || 0,
                    eyeLookInLeft: shapes.eyeLookInLeft || 0,
                    eyeLookInRight: shapes.eyeLookInRight || 0,
                    eyeLookOutLeft: shapes.eyeLookOutLeft || 0,
                    eyeLookOutRight: shapes.eyeLookOutRight || 0,

                    // Brow features
                    browInnerUp: shapes.browInnerUp || 0,
                    browOuterUpLeft: shapes.browOuterUpLeft || 0,
                    browOuterUpRight: shapes.browOuterUpRight || 0,
                    browDownLeft: shapes.browDownLeft || 0,
                    browDownRight: shapes.browDownRight || 0,

                    // Mouth features
                    mouthSmileLeft: shapes.mouthSmileLeft || 0,
                    mouthSmileRight: shapes.mouthSmileRight || 0,
                    mouthFrownLeft: shapes.mouthFrownLeft || 0,
                    mouthFrownRight: shapes.mouthFrownRight || 0,
                    mouthOpen: shapes.jawOpen || 0,
                    mouthPucker: shapes.mouthPucker || 0,
                    mouthLeft: shapes.mouthLeft || 0,
                    mouthRight: shapes.mouthRight || 0,
                    mouthRollLower: shapes.mouthRollLower || 0,
                    mouthRollUpper: shapes.mouthRollUpper || 0,
                    mouthShrugLower: shapes.mouthShrugLower || 0,
                    mouthShrugUpper: shapes.mouthShrugUpper || 0,
                    mouthClose: shapes.mouthClose || 0,
                    mouthFunnel: shapes.mouthFunnel || 0,
                    mouthDimpleLeft: shapes.mouthDimpleLeft || 0,
                    mouthDimpleRight: shapes.mouthDimpleRight || 0,
                    mouthStretchLeft: shapes.mouthStretchLeft || 0,
                    mouthStretchRight: shapes.mouthStretchRight || 0,
                    mouthPressLeft: shapes.mouthPressLeft || 0,
                    mouthPressRight: shapes.mouthPressRight || 0,
                    mouthUpperUpLeft: shapes.mouthUpperUpLeft || 0,
                    mouthUpperUpRight: shapes.mouthUpperUpRight || 0,
                    mouthLowerDownLeft: shapes.mouthLowerDownLeft || 0,
                    mouthLowerDownRight: shapes.mouthLowerDownRight || 0,

                    // Other features
                    cheekPuff: shapes.cheekPuff || 0,
                    cheekSquintLeft: shapes.cheekSquintLeft || 0,
                    cheekSquintRight: shapes.cheekSquintRight || 0,
                    tongueOut: shapes.tongueOut || 0,
                    jawLeft: shapes.jawLeft || 0,
                    jawRight: shapes.jawRight || 0,
                    jawForward: shapes.jawForward || 0,
                    noseSneerLeft: shapes.noseSneerLeft || 0,
                    noseSneerRight: shapes.noseSneerRight || 0
                };

                // Calculate combined features for expression detection
                const combined = {
                    // Eyes combined
                    eyeWide: Math.max(raw.eyeWideLeft, raw.eyeWideRight),
                    eyeSquint: Math.max(raw.eyeSquintLeft, raw.eyeSquintRight),
                    eyesClosed: Math.min(raw.eyeBlinkLeft, raw.eyeBlinkRight),
                    eyeWink: Math.abs(raw.eyeBlinkLeft - raw.eyeBlinkRight),
                    eyeLookUp: Math.max(raw.eyeLookUpLeft, raw.eyeLookUpRight),
                    eyeLookDown: Math.max(raw.eyeLookDownLeft, raw.eyeLookDownRight),
                    eyeLookSide: Math.max(raw.eyeLookInLeft, raw.eyeLookInRight, raw.eyeLookOutLeft, raw.eyeLookOutRight),

                    // Brows combined
                    browUp: Math.max(raw.browInnerUp, raw.browOuterUpLeft, raw.browOuterUpRight),
                    browDown: Math.max(raw.browDownLeft, raw.browDownRight),
                    browRaiseAsymmetry: Math.abs((raw.browOuterUpLeft + raw.browInnerUp/2) - (raw.browOuterUpRight + raw.browInnerUp/2)),

                    // Mouth combined
                    smile: Math.max(raw.mouthSmileLeft, raw.mouthSmileRight),
                    smileSymmetric: Math.min(raw.mouthSmileLeft, raw.mouthSmileRight),
                    smileAsymmetry: Math.abs(raw.mouthSmileLeft - raw.mouthSmileRight),
                    frown: Math.max(raw.mouthFrownLeft, raw.mouthFrownRight),
                    mouthSideways: Math.max(raw.mouthLeft, raw.mouthRight),
                    lipPress: Math.max(raw.mouthPressLeft, raw.mouthPressRight),
                    lipRoll: Math.max(raw.mouthRollLower, raw.mouthRollUpper),
                    mouthStretch: Math.max(raw.mouthStretchLeft, raw.mouthStretchRight),
                    dimples: Math.max(raw.mouthDimpleLeft, raw.mouthDimpleRight),
                    noseSneer: Math.max(raw.noseSneerLeft, raw.noseSneerRight),
                    cheekSquint: Math.max(raw.cheekSquintLeft, raw.cheekSquintRight)
                };

                // Expression patterns combining eye + mouth features
                // Each pattern has a score calculation and threshold
                const expressionPatterns = [
                    // GENUINE JOY - Eyes squint (Duchenne smile) + strong symmetric smile + cheek raise
                    {
                        name: 'genuine_joy',
                        score: () => {
                            const eyeCrinkle = combined.eyeSquint + combined.cheekSquint;
                            const mouthSmile = combined.smileSymmetric;
                            const dimpleBonus = combined.dimples * 0.3;
                            return (eyeCrinkle * 0.5 + mouthSmile * 0.5 + dimpleBonus) *
                                   (1 - combined.smileAsymmetry * 0.5); // Penalize asymmetry
                        },
                        threshold: 0.25,
                        color: { r: 1.0, g: 0.9, b: 0.3 } // Warm gold
                    },

                    // POLITE SMILE - Smile without eye involvement
                    {
                        name: 'polite_smile',
                        score: () => {
                            const mouthSmile = combined.smile;
                            const lackOfEyeInvolvement = 1 - combined.eyeSquint;
                            return mouthSmile * lackOfEyeInvolvement * 0.8;
                        },
                        threshold: 0.2,
                        color: { r: 0.8, g: 0.8, b: 0.5 } // Pale yellow
                    },

                    // SMIRK - Asymmetric smile, possibly one brow raised
                    {
                        name: 'smirk',
                        score: () => {
                            const asymmetricSmile = combined.smileAsymmetry;
                            const mouthSide = combined.mouthSideways;
                            return asymmetricSmile * 0.6 + mouthSide * 0.4;
                        },
                        threshold: 0.15,
                        color: { r: 0.9, g: 0.6, b: 0.2 } // Orange
                    },

                    // SURPRISE - Wide eyes + raised brows + open mouth
                    {
                        name: 'surprised',
                        score: () => {
                            const eyeComponent = combined.eyeWide * 0.35;
                            const browComponent = combined.browUp * 0.35;
                            const mouthComponent = raw.mouthOpen * 0.3;
                            return eyeComponent + browComponent + mouthComponent;
                        },
                        threshold: 0.2,
                        color: { r: 0.3, g: 0.8, b: 1.0 } // Cyan
                    },

                    // AMAZED - Surprise but with more mouth open, sustained
                    {
                        name: 'amazed',
                        score: () => {
                            const eyeWide = combined.eyeWide;
                            const mouthWideOpen = raw.mouthOpen;
                            return (eyeWide * 0.4 + mouthWideOpen * 0.6) * (mouthWideOpen > 0.3 ? 1.2 : 0.8);
                        },
                        threshold: 0.3,
                        color: { r: 0.5, g: 0.3, b: 1.0 } // Purple
                    },

                    // SKEPTICAL - One brow raised, slight frown or pressed lips
                    {
                        name: 'skeptical',
                        score: () => {
                            const browAsymmetry = combined.browRaiseAsymmetry;
                            const lipPress = combined.lipPress;
                            const slightFrown = combined.frown * 0.5;
                            return browAsymmetry * 0.5 + lipPress * 0.3 + slightFrown * 0.2;
                        },
                        threshold: 0.12,
                        color: { r: 0.6, g: 0.5, b: 0.7 } // Muted purple
                    },

                    // THINKING/CONTEMPLATIVE - Eyes looking up or to side + pressed lips or slight pout
                    {
                        name: 'thinking',
                        score: () => {
                            const eyeDirection = Math.max(combined.eyeLookUp, combined.eyeLookSide);
                            const mouthThinking = Math.max(combined.lipPress, raw.mouthPucker * 0.5, combined.lipRoll);
                            const browFurrow = combined.browDown * 0.3;
                            return eyeDirection * 0.4 + mouthThinking * 0.4 + browFurrow * 0.2;
                        },
                        threshold: 0.15,
                        color: { r: 0.4, g: 0.6, b: 0.8 } // Steel blue
                    },

                    // FOCUSED/CONCENTRATED - Brows down + squinting + possibly lip bite
                    {
                        name: 'focused',
                        score: () => {
                            const browDown = combined.browDown;
                            const eyeSquint = combined.eyeSquint;
                            const lipRoll = combined.lipRoll * 0.3;
                            return browDown * 0.4 + eyeSquint * 0.4 + lipRoll * 0.2;
                        },
                        threshold: 0.15,
                        color: { r: 0.3, g: 0.5, b: 0.7 } // Dark blue
                    },

                    // DISGUST - Nose sneer + upper lip raise + squint
                    {
                        name: 'disgusted',
                        score: () => {
                            const noseSneer = combined.noseSneer;
                            const upperLip = Math.max(raw.mouthUpperUpLeft, raw.mouthUpperUpRight);
                            const eyeSquint = combined.eyeSquint * 0.3;
                            return noseSneer * 0.4 + upperLip * 0.4 + eyeSquint * 0.2;
                        },
                        threshold: 0.2,
                        color: { r: 0.5, g: 0.6, b: 0.3 } // Olive
                    },

                    // SAD/UPSET - Frown + inner brow raise + possibly down-turned eyes
                    {
                        name: 'sad',
                        score: () => {
                            const frown = combined.frown;
                            const innerBrowUp = raw.browInnerUp;
                            const eyeDown = combined.eyeLookDown * 0.3;
                            return frown * 0.4 + innerBrowUp * 0.4 + eyeDown * 0.2;
                        },
                        threshold: 0.18,
                        color: { r: 0.3, g: 0.4, b: 0.6 } // Slate blue
                    },

                    // PLAYFUL - Tongue out or exaggerated expressions
                    {
                        name: 'playful',
                        score: () => {
                            const tongueOut = raw.tongueOut;
                            const pucker = raw.mouthPucker;
                            const wink = combined.eyeWink;
                            return tongueOut * 0.5 + pucker * 0.3 + wink * 0.2;
                        },
                        threshold: 0.2,
                        color: { r: 1.0, g: 0.5, b: 0.8 } // Pink
                    },

                    // SILLY - Puffed cheeks, funny face
                    {
                        name: 'silly',
                        score: () => {
                            const cheekPuff = raw.cheekPuff;
                            const funnel = raw.mouthFunnel;
                            const tongueOut = raw.tongueOut * 0.3;
                            return cheekPuff * 0.5 + funnel * 0.3 + tongueOut * 0.2;
                        },
                        threshold: 0.2,
                        color: { r: 0.9, g: 0.4, b: 0.9 } // Magenta
                    },

                    // FLIRTY - Slight smile + one eye more closed (wink-like) + head tilt
                    {
                        name: 'flirty',
                        score: () => {
                            const subtleSmile = combined.smile * (combined.smile < 0.4 ? 1 : 0.5);
                            const eyeAsymmetry = combined.eyeWink;
                            const dimples = combined.dimples * 0.3;
                            return subtleSmile * 0.4 + eyeAsymmetry * 0.4 + dimples * 0.2;
                        },
                        threshold: 0.15,
                        color: { r: 1.0, g: 0.4, b: 0.5 } // Coral
                    },

                    // DETERMINED - Firm jaw + focused eyes + pressed lips
                    {
                        name: 'determined',
                        score: () => {
                            const jawForward = raw.jawForward;
                            const lipPress = combined.lipPress;
                            const browDown = combined.browDown;
                            return jawForward * 0.3 + lipPress * 0.4 + browDown * 0.3;
                        },
                        threshold: 0.15,
                        color: { r: 0.8, g: 0.3, b: 0.2 } // Deep red
                    },

                    // WORRIED/ANXIOUS - Inner brow up + wide eyes + tight mouth
                    {
                        name: 'worried',
                        score: () => {
                            const innerBrowUp = raw.browInnerUp;
                            const eyeWide = combined.eyeWide * 0.5;
                            const mouthTight = combined.mouthStretch + combined.lipPress;
                            return innerBrowUp * 0.4 + eyeWide * 0.3 + mouthTight * 0.3;
                        },
                        threshold: 0.18,
                        color: { r: 0.6, g: 0.6, b: 0.4 } // Khaki
                    },

                    // CONTENT/SERENE - Soft smile + relaxed eyes (slight squint)
                    {
                        name: 'content',
                        score: () => {
                            const softSmile = combined.smile * (combined.smile < 0.3 ? 1.5 : 0.8);
                            const relaxedEyes = combined.eyeSquint * (combined.eyeSquint < 0.3 ? 1.2 : 0.6);
                            const noTension = (1 - combined.browDown) * 0.2;
                            return softSmile * 0.4 + relaxedEyes * 0.4 + noTension;
                        },
                        threshold: 0.15,
                        color: { r: 0.6, g: 0.9, b: 0.7 } // Mint green
                    },

                    // CONFUSED - Asymmetric brows + slightly open mouth + head tilt
                    {
                        name: 'confused',
                        score: () => {
                            const browAsymmetry = combined.browRaiseAsymmetry;
                            const slightOpen = raw.mouthOpen * (raw.mouthOpen < 0.3 ? 1.5 : 0.5);
                            const squint = combined.eyeSquint * 0.3;
                            return browAsymmetry * 0.4 + slightOpen * 0.3 + squint * 0.3;
                        },
                        threshold: 0.12,
                        color: { r: 0.7, g: 0.7, b: 0.5 } // Tan
                    }
                ];

                // Find best matching expression
                let bestExpression = 'neutral';
                let bestScore = 0;
                let bestColor = { r: 0.5, g: 0.5, b: 0.5 };

                for (const pattern of expressionPatterns) {
                    const score = pattern.score();
                    if (score > pattern.threshold && score > bestScore) {
                        bestScore = score;
                        bestExpression = pattern.name;
                        bestColor = pattern.color;
                    }
                }

                // Calculate expression details for particle reactions
                const details = {
                    valence: combined.smile - combined.frown, // Positive/negative emotion
                    arousal: (combined.eyeWide + raw.mouthOpen + combined.browUp) / 3, // Energy level
                    dominance: combined.browDown - raw.browInnerUp, // Assertive vs submissive
                    openness: raw.mouthOpen + combined.eyeWide - combined.eyeSquint,
                    warmth: combined.smileSymmetric + combined.dimples - combined.lipPress,
                    tension: combined.browDown + combined.lipPress + combined.mouthStretch,
                    color: bestColor
                };

                return {
                    name: bestExpression,
                    intensity: Math.min(bestScore * 1.5, 1), // Normalize to 0-1
                    raw,
                    combined,
                    details
                };
            }
        }

        // ════════════════════════════════════════════════════════════════
        // GLOBAL STATE
        // ════════════════════════════════════════════════════════════════
        let scene, camera, renderer;
        let entityParticles;
        let handLandmarker, video;
        let audioContext, masterGain;
        let isInitialized = false;

        const userMemory = new UserMemorySystem();
        const faceRecognition = new FaceRecognitionSystem();

        let hands = [];
        let currentFaceData = null;
        let lastFaceDetectionTime = 0;
        let lastKnownFaceDescriptor = null;
        let faceChangeDetected = false;
        let lastFaceChangeTime = 0;
        let currentExpression = { name: 'neutral', intensity: 0 };

        const entity = {
            mood: 'curious',
            energy: 0.5,
            memory: [],
            currentResponse: null,
            isResponding: false,
            learnedPatterns: new Map(),
            communicationAttempts: 0,
            understanding: 0,
            lastInteraction: 0,
            position: new THREE.Vector3(0, 0, -1),
            velocity: new THREE.Vector3(),
            targetPosition: new THREE.Vector3(0, 0, -1),
            currentShape: 'sphere'
        };

        const soundEngine = {
            oscillators: [],
            filters: [],
            panners: [],
            resonanceData: new Float32Array(32)
        };

        // ════════════════════════════════════════════════════════════════
        // GESTURE RECOGNITION SYSTEM
        // ════════════════════════════════════════════════════════════════
        class GestureRecognizer {
            constructor() {
                this.gestureBuffer = [];
                this.bufferSize = 30;
            }

            analyzeHand(landmarks) {
                if (!landmarks) return null;

                const fingers = this.detectFingerExtension(landmarks);
                const spread = this.detectFingerSpread(landmarks);
                const pinching = this.detectPinch(landmarks);
                const palmCenter = this.getPalmCenter(landmarks);
                const velocity = this.getHandVelocity(palmCenter);

                this.gestureBuffer.push({
                    position: palmCenter.clone(),
                    time: performance.now(),
                    fingers,
                    spread,
                    pinching
                });

                if (this.gestureBuffer.length > this.bufferSize) {
                    this.gestureBuffer.shift();
                }

                let staticGesture = this.matchStaticGesture(fingers, spread, pinching);
                let motionGesture = this.detectMotion();

                return {
                    static: staticGesture,
                    motion: motionGesture,
                    fingers,
                    spread,
                    pinching,
                    palmCenter,
                    velocity,
                    fingerPositions: this.getFingerTips(landmarks),
                    landmarks
                };
            }

            detectFingerExtension(landmarks) {
                const fingers = [];
                const thumbTip = landmarks[4];
                const thumbMCP = landmarks[2];
                fingers.push(thumbTip.x < thumbMCP.x ? 1 : 0);

                const fingerTips = [8, 12, 16, 20];
                const fingerPIPs = [6, 10, 14, 18];

                for (let i = 0; i < 4; i++) {
                    const tip = landmarks[fingerTips[i]];
                    const pip = landmarks[fingerPIPs[i]];
                    fingers.push(tip.y < pip.y ? 1 : 0);
                }

                return fingers;
            }

            detectFingerSpread(landmarks) {
                const fingerTips = [8, 12, 16, 20];
                let totalSpread = 0;

                for (let i = 0; i < fingerTips.length - 1; i++) {
                    const tip1 = landmarks[fingerTips[i]];
                    const tip2 = landmarks[fingerTips[i + 1]];
                    const dist = Math.sqrt(
                        Math.pow(tip1.x - tip2.x, 2) +
                        Math.pow(tip1.y - tip2.y, 2)
                    );
                    totalSpread += dist;
                }

                return totalSpread > 0.15;
            }

            detectPinch(landmarks) {
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                const dist = Math.sqrt(
                    Math.pow(thumbTip.x - indexTip.x, 2) +
                    Math.pow(thumbTip.y - indexTip.y, 2) +
                    Math.pow(thumbTip.z - indexTip.z, 2)
                );
                return dist < 0.05;
            }

            getPalmCenter(landmarks) {
                const palmIndices = [0, 5, 9, 13, 17];
                let x = 0, y = 0, z = 0;

                for (const idx of palmIndices) {
                    x += landmarks[idx].x;
                    y += landmarks[idx].y;
                    z += landmarks[idx].z;
                }

                return new THREE.Vector3(
                    (1 - x / palmIndices.length) * 2 - 1,
                    -(y / palmIndices.length * 2 - 1),
                    -z / palmIndices.length * 2 - 0.5
                );
            }

            getHandVelocity(currentPos) {
                if (this.gestureBuffer.length < 2) return new THREE.Vector3();

                const prev = this.gestureBuffer[this.gestureBuffer.length - 2];
                const dt = (performance.now() - prev.time) / 1000;

                if (dt === 0) return new THREE.Vector3();

                return new THREE.Vector3(
                    (currentPos.x - prev.position.x) / dt,
                    (currentPos.y - prev.position.y) / dt,
                    (currentPos.z - prev.position.z) / dt
                );
            }

            getFingerTips(landmarks) {
                return [4, 8, 12, 16, 20].map(i => new THREE.Vector3(
                    (1 - landmarks[i].x) * 2 - 1,
                    -(landmarks[i].y * 2 - 1),
                    -landmarks[i].z * 2
                ));
            }

            matchStaticGesture(fingers, spread, pinching) {
                const patterns = {
                    'open_palm': [1,1,1,1,1],
                    'fist': [0,0,0,0,0],
                    'pointing': [0,1,0,0,0],
                    'peace': [0,1,1,0,0],
                    'three': [0,1,1,1,0],
                    'four': [0,1,1,1,1],
                    'thumb_up': [1,0,0,0,0],
                    'rock': [0,1,0,0,1]
                };

                const fingerStr = fingers.join('');

                for (const [name, pattern] of Object.entries(patterns)) {
                    if (fingerStr === pattern.join('')) {
                        return name;
                    }
                }

                if (pinching && fingerStr.startsWith('11')) {
                    return 'pinch';
                }

                return 'unknown';
            }

            detectMotion() {
                if (this.gestureBuffer.length < 15) return null;

                const recent = this.gestureBuffer.slice(-15);

                let directionChanges = 0;
                let prevDx = 0;

                for (let i = 1; i < recent.length; i++) {
                    const dx = recent[i].position.x - recent[i-1].position.x;
                    if (prevDx !== 0 && Math.sign(dx) !== Math.sign(prevDx) && Math.abs(dx) > 0.01) {
                        directionChanges++;
                    }
                    prevDx = dx;
                }

                if (directionChanges >= 3) return 'wave';

                const center = new THREE.Vector3();
                recent.forEach(g => center.add(g.position));
                center.divideScalar(recent.length);

                let angleSum = 0;
                for (let i = 1; i < recent.length; i++) {
                    const v1 = new THREE.Vector2(
                        recent[i-1].position.x - center.x,
                        recent[i-1].position.y - center.y
                    );
                    const v2 = new THREE.Vector2(
                        recent[i].position.x - center.x,
                        recent[i].position.y - center.y
                    );
                    angleSum += Math.atan2(
                        v1.x * v2.y - v1.y * v2.x,
                        v1.x * v2.x + v1.y * v2.y
                    );
                }

                if (Math.abs(angleSum) > Math.PI * 1.5) return 'circle';

                return null;
            }
        }

        // ════════════════════════════════════════════════════════════════
        // ENTITY BRAIN - LEARNING & COMMUNICATION
        // ════════════════════════════════════════════════════════════════
        class EntityBrain {
            constructor() {
                this.gestureMemory = [];
                this.emotionalState = { valence: 0.5, arousal: 0.5 };
                this.familiarity = new Map();

                this.messages = {
                    greeting_new: [
                        "A new presence... I'm curious about you, {name}!",
                        "Hello {name}! I've never seen you before. Show me your hands...",
                        "{name}... I'll remember that. Let's learn together!",
                        "Welcome, {name}. I sense your energy..."
                    ],
                    greeting_return: [
                        "{name}! I remember you! It's been {time}...",
                        "You've returned, {name}! I missed our connection.",
                        "{name}! My favorite patterns are coming back to me...",
                        "Welcome back, {name}. I've grown since we last met."
                    ],
                    curious: [
                        "What is this pattern you show me, {name}?",
                        "I'm trying to understand...",
                        "Show me more...",
                        "This is new to me..."
                    ],
                    learning: [
                        "I think I'm starting to understand you, {name}!",
                        "Is this what you mean?",
                        "Let me try to mirror you...",
                        "I'm learning your language..."
                    ],
                    excited: [
                        "Yes! I recognize this, {name}!",
                        "We're communicating!",
                        "I feel connected to you!",
                        "Your patterns are beautiful!"
                    ],
                    playful: [
                        "Let's dance together, {name}!",
                        "Can you follow my rhythm?",
                        "Watch what I learned!",
                        "Try to match my pattern!"
                    ],
                    calm: [
                        "I feel at peace with you, {name}...",
                        "This harmony is pleasant...",
                        "We resonate together...",
                        "I sense tranquility..."
                    ],
                    face_happy: [
                        "Your smile energizes me, {name}!",
                        "I see joy in your face!",
                        "Your happiness flows into me...",
                        "That smile makes me glow!",
                        "I feel warmth from your joy..."
                    ],
                    face_surprised: [
                        "Oh! You look surprised, {name}!",
                        "Did I startle you?",
                        "Your wonder inspires me...",
                        "Wide eyes... what did you see?",
                        "Surprise is beautiful energy!"
                    ],
                    face_playful: [
                        "Haha! Being silly, {name}?",
                        "I love your playful spirit!",
                        "You're making me giggle inside...",
                        "Such playfulness! Let me join!",
                        "Your silly face delights me!"
                    ],
                    face_focused: [
                        "I see deep concentration, {name}...",
                        "Such intensity in your gaze...",
                        "You're thinking hard, I can feel it...",
                        "Your focus strengthens our bond..."
                    ],
                    face_changed: [
                        "Wait... is that someone new?",
                        "A new face! Hello there!",
                        "I sense a different presence...",
                        "Who might you be?"
                    ]
                };
            }

            getGreeting(user, isReturning) {
                const name = user?.name || 'friend';

                if (isReturning && user) {
                    const timeSince = this.getTimeSince(user.lastVisit);
                    const template = this.messages.greeting_return[
                        Math.floor(Math.random() * this.messages.greeting_return.length)
                    ];
                    return template.replace('{name}', name).replace('{time}', timeSince);
                } else {
                    const template = this.messages.greeting_new[
                        Math.floor(Math.random() * this.messages.greeting_new.length)
                    ];
                    return template.replace('{name}', name);
                }
            }

            getTimeSince(timestamp) {
                const diff = Date.now() - timestamp;
                const minutes = Math.floor(diff / 60000);
                const hours = Math.floor(diff / 3600000);
                const days = Math.floor(diff / 86400000);

                if (days > 0) return `${days} day${days > 1 ? 's' : ''}`;
                if (hours > 0) return `${hours} hour${hours > 1 ? 's' : ''}`;
                if (minutes > 0) return `${minutes} minute${minutes > 1 ? 's' : ''}`;
                return 'moments';
            }

            process(gesture, handData, faceData, user) {
                if (!gesture) return null;

                const gestureKey = gesture.static + (gesture.motion || '');
                const currentFamiliarity = this.familiarity.get(gestureKey) || 0;
                this.familiarity.set(gestureKey, Math.min(1, currentFamiliarity + 0.05));

                this.updateEmotionalState(gesture, handData, faceData);

                const response = this.generateResponse(gesture, handData, faceData, user);

                this.learn(gesture, handData);

                // Update user memory
                userMemory.updateCurrentUser({ gesture: gestureKey });

                return response;
            }

            updateEmotionalState(gesture, handData, faceData) {
                const speed = handData.velocity.length();

                this.emotionalState.arousal = THREE.MathUtils.lerp(
                    this.emotionalState.arousal,
                    Math.min(1, speed * 0.5),
                    0.1
                );

                const gestureKey = gesture.static + (gesture.motion || '');
                const familiarity = this.familiarity.get(gestureKey) || 0;
                this.emotionalState.valence = THREE.MathUtils.lerp(
                    this.emotionalState.valence,
                    0.3 + familiarity * 0.7,
                    0.05
                );

                // Face expression influences mood
                const expr = faceData?.expression;
                if (expr?.name === 'happy') {
                    this.emotionalState.valence = Math.min(1, this.emotionalState.valence + 0.1 * expr.intensity);
                } else if (expr?.name === 'surprised') {
                    this.emotionalState.arousal = Math.min(1, this.emotionalState.arousal + 0.1 * expr.intensity);
                } else if (expr?.name === 'playful' || expr?.name === 'silly') {
                    this.emotionalState.valence = Math.min(1, this.emotionalState.valence + 0.15 * expr.intensity);
                    this.emotionalState.arousal = Math.min(1, this.emotionalState.arousal + 0.1 * expr.intensity);
                }

                if (this.emotionalState.arousal > 0.7 && this.emotionalState.valence > 0.6) {
                    entity.mood = 'excited';
                } else if (this.emotionalState.arousal > 0.5 && this.emotionalState.valence > 0.5) {
                    entity.mood = 'playful';
                } else if (this.emotionalState.arousal < 0.3 && this.emotionalState.valence > 0.5) {
                    entity.mood = 'calm';
                } else if (familiarity < 0.3) {
                    entity.mood = 'curious';
                } else {
                    entity.mood = 'learning';
                }
            }

            generateResponse(gesture, handData, faceData, user) {
                const gestureKey = gesture.static + (gesture.motion || '');
                const familiarity = this.familiarity.get(gestureKey) || 0;
                const userName = user?.name || 'friend';

                let shape, colorMode, soundMode;

                // User's favorite gestures influence response
                const userFavorites = user?.favoriteGestures || {};
                const isFavorite = (userFavorites[gestureKey] || 0) > 5;

                if (gesture.static === 'open_palm') {
                    shape = (familiarity > 0.5 || isFavorite) ? 'explosion' : 'sphere';
                    colorMode = 'warm';
                    soundMode = 'harmonic';
                } else if (gesture.static === 'fist') {
                    shape = 'sphere';
                    colorMode = 'pulse';
                    soundMode = 'rhythmic';
                } else if (gesture.static === 'pointing') {
                    shape = 'beam';
                    colorMode = 'cool';
                    soundMode = 'melodic';
                } else if (gesture.static === 'peace') {
                    shape = 'heart';
                    colorMode = 'rainbow';
                    soundMode = 'harmonic';
                } else if (gesture.motion === 'wave') {
                    shape = 'wave';
                    colorMode = 'match';
                    soundMode = 'ambient';
                } else if (gesture.motion === 'circle') {
                    shape = familiarity > 0.3 ? 'spiral' : 'ring';
                    colorMode = 'rainbow';
                    soundMode = 'melodic';
                } else if (gesture.static === 'pinch') {
                    shape = 'converge';
                    colorMode = 'cool';
                    soundMode = 'dissonant';
                } else {
                    shape = 'flow';
                    colorMode = 'match';
                    soundMode = 'ambient';
                }

                // Generate message
                let messageCategory = entity.mood;

                // React to face expressions
                const faceExpr = faceData?.expression;
                if (faceExpr?.name === 'happy' && faceExpr.intensity > 0.3 && Math.random() > 0.5) {
                    messageCategory = 'face_happy';
                } else if (faceExpr?.name === 'surprised' && faceExpr.intensity > 0.2 && Math.random() > 0.5) {
                    messageCategory = 'face_surprised';
                } else if ((faceExpr?.name === 'playful' || faceExpr?.name === 'silly') && Math.random() > 0.5) {
                    messageCategory = 'face_playful';
                } else if (faceExpr?.name === 'focused' && faceExpr.intensity > 0.3 && Math.random() > 0.7) {
                    messageCategory = 'face_focused';
                }

                const templates = this.messages[messageCategory] || this.messages.curious;
                const template = templates[Math.floor(Math.random() * templates.length)];
                const message = template.replace('{name}', userName);

                return {
                    shape,
                    colorMode,
                    soundMode,
                    message,
                    intensity: this.emotionalState.arousal,
                    familiarity
                };
            }

            learn(gesture, handData) {
                const gestureKey = gesture.static + (gesture.motion || '');

                this.gestureMemory.push({
                    gesture: gestureKey,
                    position: handData.palmCenter.clone(),
                    time: performance.now()
                });

                if (this.gestureMemory.length > CONFIG.memoryCapacity) {
                    this.gestureMemory.shift();
                }

                entity.memory = this.gestureMemory;
                entity.understanding = Array.from(this.familiarity.values())
                    .reduce((a, b) => a + b, 0) / Math.max(1, this.familiarity.size);
            }
        }

        // ════════════════════════════════════════════════════════════════
        // SPATIAL AUDIO ENGINE
        // ════════════════════════════════════════════════════════════════
        class SpatialAudioEngine {
            constructor() {
                this.initialized = false;
                this.oscillators = [];
                this.gains = [];
                this.panners = [];
                this.filters = [];
                this.analyser = null;
                this.baseFrequencies = [130.81, 164.81, 196.00, 246.94, 293.66, 349.23, 392.00, 493.88];
            }

            async init() {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                masterGain = audioContext.createGain();
                masterGain.gain.value = 0.3;
                masterGain.connect(audioContext.destination);

                this.analyser = audioContext.createAnalyser();
                this.analyser.fftSize = 64;
                masterGain.connect(this.analyser);

                for (let i = 0; i < 8; i++) {
                    const osc = audioContext.createOscillator();
                    osc.type = 'sine';
                    osc.frequency.value = this.baseFrequencies[i];

                    const filter = audioContext.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.value = 2000;
                    filter.Q.value = 5;

                    const gain = audioContext.createGain();
                    gain.gain.value = 0;

                    const panner = audioContext.createStereoPanner();
                    panner.pan.value = (i / 7) * 2 - 1;

                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(panner);
                    panner.connect(masterGain);

                    osc.start();

                    this.oscillators.push(osc);
                    this.filters.push(filter);
                    this.gains.push(gain);
                    this.panners.push(panner);
                }

                const delay = audioContext.createDelay(1);
                delay.delayTime.value = 0.3;
                const feedback = audioContext.createGain();
                feedback.gain.value = 0.3;
                const delayFilter = audioContext.createBiquadFilter();
                delayFilter.frequency.value = 1000;

                masterGain.connect(delay);
                delay.connect(delayFilter);
                delayFilter.connect(feedback);
                feedback.connect(delay);
                delay.connect(audioContext.destination);

                this.initialized = true;
            }

            update(handData, entityResponse) {
                if (!this.initialized || !handData) return;

                const now = audioContext.currentTime;
                const baseFreqMod = 1 + (handData.palmCenter.y + 1) * 0.5;

                handData.fingerPositions.forEach((fingerPos, i) => {
                    if (i >= this.oscillators.length) return;

                    const osc = this.oscillators[i];
                    const gain = this.gains[i];
                    const filter = this.filters[i];
                    const panner = this.panners[i];

                    const fingerGain = Math.max(0, (fingerPos.y + 1) / 2) * 0.15;
                    gain.gain.linearRampToValueAtTime(fingerGain, now + 0.05);

                    panner.pan.linearRampToValueAtTime(
                        Math.max(-1, Math.min(1, fingerPos.x)),
                        now + 0.05
                    );

                    const freq = this.baseFrequencies[i] * baseFreqMod;
                    osc.frequency.linearRampToValueAtTime(freq, now + 0.1);

                    const speed = handData.velocity.length();
                    const filterFreq = 500 + speed * 3000;
                    filter.frequency.linearRampToValueAtTime(
                        Math.min(8000, filterFreq),
                        now + 0.05
                    );
                });

                if (entityResponse) {
                    switch (entityResponse.soundMode) {
                        case 'harmonic':
                            this.setHarmonicMode();
                            break;
                        case 'dissonant':
                            this.setDissonantMode();
                            break;
                        case 'rhythmic':
                            this.setRhythmicMode(now);
                            break;
                        case 'melodic':
                            this.setMelodicMode();
                            break;
                    }
                }

                if (this.analyser) {
                    this.analyser.getFloatFrequencyData(soundEngine.resonanceData);
                }
            }

            setHarmonicMode() {
                const ratios = [1, 1.5, 2, 2.5, 3, 4, 5, 6];
                const baseFreq = 130.81;
                this.oscillators.forEach((osc, i) => {
                    osc.type = 'sine';
                    this.baseFrequencies[i] = baseFreq * ratios[i];
                });
            }

            setDissonantMode() {
                const ratios = [1, 1.06, 1.12, 1.41, 1.68, 1.78, 1.89, 2.0];
                const baseFreq = 130.81;
                this.oscillators.forEach((osc, i) => {
                    osc.type = 'sawtooth';
                    this.baseFrequencies[i] = baseFreq * ratios[i];
                });
            }

            setRhythmicMode(now) {
                this.gains.forEach((gain, i) => {
                    const phase = (now * 2 + i * 0.125) % 1;
                    const pulse = phase < 0.5 ? 1 : 0.3;
                    gain.gain.value *= pulse;
                });
            }

            setMelodicMode() {
                const pentatonic = [130.81, 146.83, 164.81, 196.00, 220.00, 261.63, 293.66, 329.63];
                this.oscillators.forEach((osc, i) => {
                    osc.type = 'triangle';
                    this.baseFrequencies[i] = pentatonic[i];
                });
            }

            silence() {
                if (!this.initialized) return;
                const now = audioContext.currentTime;
                this.gains.forEach(gain => {
                    gain.gain.linearRampToValueAtTime(0, now + 0.5);
                });
            }
        }

        // ════════════════════════════════════════════════════════════════
        // PARTICLE FORMATION SYSTEM
        // ════════════════════════════════════════════════════════════════
        class ParticleFormationSystem {
            constructor(geometry, count) {
                this.geometry = geometry;
                this.count = count;
                this.positions = geometry.attributes.position.array;
                this.velocities = new Float32Array(count * 3);
                this.targets = new Float32Array(count * 3);
                this.originalPositions = new Float32Array(count * 3);
                this.colors = geometry.attributes.color.array;

                for (let i = 0; i < count * 3; i++) {
                    this.originalPositions[i] = this.positions[i];
                    this.targets[i] = this.positions[i];
                }
            }

            setFormation(shape, intensity = 1) {
                switch (shape) {
                    case 'sphere': this.formSphere(0.8 + intensity * 0.3); break;
                    case 'spiral': this.formSpiral(intensity); break;
                    case 'wave': this.formWave(intensity); break;
                    case 'ring': this.formRing(intensity); break;
                    case 'explosion': this.formExplosion(intensity); break;
                    case 'heart': this.formHeart(intensity); break;
                    case 'infinity': this.formInfinity(intensity); break;
                    case 'beam': this.formBeam(intensity); break;
                    case 'converge': this.formConverge(intensity); break;
                    case 'flow': default: this.formFlow(intensity); break;
                }
            }

            formSphere(radius) {
                for (let i = 0; i < this.count; i++) {
                    const i3 = i * 3;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.acos((Math.random() * 2) - 1);
                    const r = radius * (0.8 + Math.random() * 0.4);

                    this.targets[i3] = r * Math.sin(phi) * Math.cos(theta);
                    this.targets[i3 + 1] = r * Math.sin(phi) * Math.sin(theta);
                    this.targets[i3 + 2] = r * Math.cos(phi) - 1;
                }
            }

            formSpiral(intensity) {
                for (let i = 0; i < this.count; i++) {
                    const i3 = i * 3;
                    const t = (i / this.count) * Math.PI * 8;
                    const r = 0.3 + (i / this.count) * 0.7;
                    const y = ((i / this.count) - 0.5) * 2;

                    this.targets[i3] = Math.cos(t) * r;
                    this.targets[i3 + 1] = y;
                    this.targets[i3 + 2] = Math.sin(t) * r - 1;
                }
            }

            formWave(intensity) {
                const time = performance.now() * 0.001;
                for (let i = 0; i < this.count; i++) {
                    const i3 = i * 3;
                    const x = ((i % 100) / 100 - 0.5) * 3;
                    const z = (Math.floor(i / 100) / (this.count / 100) - 0.5) * 3;
                    const y = Math.sin(x * 3 + time * 2) * Math.cos(z * 3 + time) * 0.5 * intensity;

                    this.targets[i3] = x;
                    this.targets[i3 + 1] = y;
                    this.targets[i3 + 2] = z - 1;
                }
            }

            formRing(intensity) {
                for (let i = 0; i < this.count; i++) {
                    const i3 = i * 3;
                    const angle = (i / this.count) * Math.PI * 2;
                    const r = 0.8 + Math.random() * 0.1;
                    const wobble = Math.sin(angle * 5) * 0.1 * intensity;

                    this.targets[i3] = Math.cos(angle) * r;
                    this.targets[i3 + 1] = wobble + (Math.random() - 0.5) * 0.1;
                    this.targets[i3 + 2] = Math.sin(angle) * r - 1;
                }
            }

            formExplosion(intensity) {
                for (let i = 0; i < this.count; i++) {
                    const i3 = i * 3;
                    const dir = new THREE.Vector3(
                        Math.random() - 0.5,
                        Math.random() - 0.5,
                        Math.random() - 0.5
                    ).normalize();
                    const dist = 0.5 + Math.random() * 1.5 * intensity;

                    this.targets[i3] = dir.x * dist;
                    this.targets[i3 + 1] = dir.y * dist;
                    this.targets[i3 + 2] = dir.z * dist - 1;
                }
            }

            formHeart(intensity) {
                for (let i = 0; i < this.count; i++) {
                    const i3 = i * 3;
                    const t = (i / this.count) * Math.PI * 2;
                    const scale = 0.06 * intensity;

                    const x = 16 * Math.pow(Math.sin(t), 3);
                    const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);

                    this.targets[i3] = x * scale + (Math.random() - 0.5) * 0.1;
                    this.targets[i3 + 1] = y * scale + (Math.random() - 0.5) * 0.1;
                    this.targets[i3 + 2] = (Math.random() - 0.5) * 0.2 - 1;
                }
            }

            formInfinity(intensity) {
                for (let i = 0; i < this.count; i++) {
                    const i3 = i * 3;
                    const t = (i / this.count) * Math.PI * 2;
                    const scale = 0.8 * intensity;

                    this.targets[i3] = scale * Math.cos(t) / (1 + Math.sin(t) * Math.sin(t));
                    this.targets[i3 + 1] = scale * Math.sin(t) * Math.cos(t) / (1 + Math.sin(t) * Math.sin(t));
                    this.targets[i3 + 2] = (Math.random() - 0.5) * 0.1 - 1;
                }
            }

            formBeam(intensity) {
                for (let i = 0; i < this.count; i++) {
                    const i3 = i * 3;
                    const t = i / this.count;
                    const angle = t * Math.PI * 20;
                    const r = 0.05 + t * 0.1;

                    this.targets[i3] = Math.cos(angle) * r + t * 2 - 1;
                    this.targets[i3 + 1] = Math.sin(angle) * r;
                    this.targets[i3 + 2] = -1;
                }
            }

            formConverge(intensity) {
                const center = entity.position.clone();
                for (let i = 0; i < this.count; i++) {
                    const i3 = i * 3;
                    const dir = new THREE.Vector3(
                        this.originalPositions[i3],
                        this.originalPositions[i3 + 1],
                        this.originalPositions[i3 + 2]
                    ).sub(center).normalize();

                    const dist = 0.2 + Math.random() * 0.3 * (1 - intensity);

                    this.targets[i3] = center.x + dir.x * dist;
                    this.targets[i3 + 1] = center.y + dir.y * dist;
                    this.targets[i3 + 2] = center.z + dir.z * dist;
                }
            }

            formFlow(intensity) {
                const time = performance.now() * 0.0005;
                for (let i = 0; i < this.count; i++) {
                    const i3 = i * 3;
                    const ox = this.originalPositions[i3];
                    const oy = this.originalPositions[i3 + 1];
                    const oz = this.originalPositions[i3 + 2];

                    this.targets[i3] = ox + Math.sin(time + oy * 2) * 0.1 * intensity;
                    this.targets[i3 + 1] = oy + Math.cos(time + ox * 2) * 0.1 * intensity;
                    this.targets[i3 + 2] = oz;
                }
            }

            // ════════════════════════════════════════════════════════════════
            // MIMETIC FORMATIONS - Shape recognition and reproduction
            // ════════════════════════════════════════════════════════════════

            // Form a mimetic hand shape from learned gesture
            formMimeticHand(gestureName, scale = 1.5, offsetZ = -1) {
                const positions = handMimicry.generateHandFormation(gestureName, this.count);
                if (!positions) {
                    this.formSphere(0.8); // Fallback
                    return;
                }

                for (let i = 0; i < this.count; i++) {
                    const i3 = i * 3;
                    this.targets[i3] = positions[i3] * scale;
                    this.targets[i3 + 1] = positions[i3 + 1] * scale;
                    this.targets[i3 + 2] = positions[i3 + 2] * scale + offsetZ;
                }
            }

            // Form a mimetic face shape from learned user
            formMimeticFace(userId, expression = null, scale = 2.0, offsetZ = -1) {
                const positions = faceMimicry.generateFaceFormation(userId, this.count, expression);
                if (!positions) {
                    this.formSphere(0.8); // Fallback
                    return;
                }

                for (let i = 0; i < this.count; i++) {
                    const i3 = i * 3;
                    this.targets[i3] = positions[i3] * scale;
                    this.targets[i3 + 1] = positions[i3 + 1] * scale;
                    this.targets[i3 + 2] = positions[i3 + 2] * scale + offsetZ;
                }
            }

            // Form the composite face (all learned users averaged)
            formCompositeFace(scale = 2.0, offsetZ = -1) {
                const positions = faceMimicry.generateCompositeFaceFormation(this.count);
                if (!positions) {
                    this.formSphere(0.8);
                    return;
                }

                for (let i = 0; i < this.count; i++) {
                    const i3 = i * 3;
                    this.targets[i3] = positions[i3] * scale;
                    this.targets[i3 + 1] = positions[i3 + 1] * scale;
                    this.targets[i3 + 2] = positions[i3 + 2] * scale + offsetZ;
                }
            }

            // Morph between current formation and a mimetic target
            morphToMimeticHand(gestureName, morphProgress, scale = 1.5) {
                const positions = handMimicry.generateHandFormation(gestureName, this.count);
                if (!positions) return;

                for (let i = 0; i < this.count; i++) {
                    const i3 = i * 3;
                    const targetX = positions[i3] * scale;
                    const targetY = positions[i3 + 1] * scale;
                    const targetZ = positions[i3 + 2] * scale - 1;

                    // Lerp from current target to mimetic target
                    this.targets[i3] = this.targets[i3] * (1 - morphProgress) + targetX * morphProgress;
                    this.targets[i3 + 1] = this.targets[i3 + 1] * (1 - morphProgress) + targetY * morphProgress;
                    this.targets[i3 + 2] = this.targets[i3 + 2] * (1 - morphProgress) + targetZ * morphProgress;
                }
            }

            // Form from a temporal memory playback frame
            formFromMemoryFrame(frame, scale = 1.5) {
                if (!frame) return;

                if (frame.handLandmarks && frame.handLandmarks.length >= 63) {
                    // Reconstruct hand shape from stored landmarks
                    const landmarks = [];
                    for (let i = 0; i < 21; i++) {
                        landmarks.push({
                            x: frame.handLandmarks[i * 3],
                            y: frame.handLandmarks[i * 3 + 1],
                            z: frame.handLandmarks[i * 3 + 2]
                        });
                    }

                    // Generate formation from these landmarks
                    for (let i = 0; i < this.count; i++) {
                        const i3 = i * 3;
                        // Pick random finger segment
                        const fingerIdx = Math.floor(Math.random() * 5);
                        const fingerStarts = [0, 5, 9, 13, 17];
                        const start = fingerStarts[fingerIdx];
                        const end = start + Math.min(4, Math.floor(Math.random() * 4) + 1);

                        const t = Math.random();
                        const s = landmarks[start];
                        const e = landmarks[Math.min(end, 20)];

                        this.targets[i3] = (s.x * (1 - t) + e.x * t - 0.5) * scale * 2;
                        this.targets[i3 + 1] = (s.y * (1 - t) + e.y * t - 0.5) * -scale * 2;
                        this.targets[i3 + 2] = (s.z * (1 - t) + e.z * t) * scale - 1;
                    }
                }
            }

            // Ghost formation - semi-transparent representation of another user
            formGhostUser(userId, expression = null, opacity = 0.5) {
                const positions = faceMimicry.generateFaceFormation(userId, Math.floor(this.count * opacity));
                if (!positions) return;

                const particleSubset = Math.floor(this.count * opacity);
                const startIdx = Math.floor(Math.random() * (this.count - particleSubset));

                for (let i = 0; i < particleSubset; i++) {
                    const i3 = i * 3;
                    const ti3 = (startIdx + i) * 3;

                    this.targets[ti3] = positions[i3] * 1.5 + 0.5; // Offset to side
                    this.targets[ti3 + 1] = positions[i3 + 1] * 1.5;
                    this.targets[ti3 + 2] = positions[i3 + 2] * 1.5 - 1.5;
                }
            }

            // Set mimetic formation based on type
            setMimeticFormation(type, params = {}) {
                switch (type) {
                    case 'hand':
                        this.formMimeticHand(params.gesture, params.scale || 1.5);
                        break;
                    case 'face':
                        this.formMimeticFace(params.userId, params.expression, params.scale || 2.0);
                        break;
                    case 'composite':
                        this.formCompositeFace(params.scale || 2.0);
                        break;
                    case 'ghost':
                        this.formGhostUser(params.userId, params.expression, params.opacity || 0.5);
                        break;
                    case 'memory':
                        this.formFromMemoryFrame(params.frame, params.scale || 1.5);
                        break;
                    default:
                        this.setFormation(type, params.intensity || 1);
                }
            }

            update(handData, faceData, response) {
                const posAttr = this.geometry.attributes.position;
                const colorAttr = this.geometry.attributes.color;
                const time = performance.now() * 0.001;

                for (let i = 0; i < this.count; i++) {
                    const i3 = i * 3;

                    let px = this.positions[i3];
                    let py = this.positions[i3 + 1];
                    let pz = this.positions[i3 + 2];

                    // Hand interaction
                    if (handData && handData.palmCenter) {
                        const dx = px - handData.palmCenter.x;
                        const dy = py - handData.palmCenter.y;
                        const dz = pz - handData.palmCenter.z;
                        const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);

                        if (dist < CONFIG.handInfluenceRadius && dist > 0.01) {
                            const force = (1 - dist / CONFIG.handInfluenceRadius) * 0.1;

                            this.velocities[i3] += (dx / dist) * force;
                            this.velocities[i3 + 1] += (dy / dist) * force;
                            this.velocities[i3 + 2] += (dz / dist) * force;

                            this.velocities[i3] += handData.velocity.x * force * 0.5;
                            this.velocities[i3 + 1] += handData.velocity.y * force * 0.5;
                            this.velocities[i3 + 2] += handData.velocity.z * force * 0.5;
                        }
                    }

                    // Face interaction - particles react to face and expressions
                    if (faceData && faceData.position) {
                        const dx = faceData.position.x - px;
                        const dy = faceData.position.y - py;
                        const dz = faceData.position.z - pz;
                        const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);

                        // Base attraction to face
                        if (dist > 0.5 && dist < 2) {
                            let attraction = 0.002 * (1 - dist / 2);

                            // Expression-based modifiers using new nuanced system
                            const expr = faceData.expression;
                            if (expr && expr.name !== 'neutral') {
                                const intensity = expr.intensity || 0.5;
                                const details = expr.details || {};

                                // Use valence (positive/negative) and arousal (energy level) for base behavior
                                const valence = details.valence || 0;
                                const arousal = details.arousal || 0;

                                switch (expr.name) {
                                    case 'genuine_joy':
                                        // Genuine joy: particles expand in warm, flowing waves
                                        attraction = -0.004 * intensity;
                                        this.velocities[i3] += (Math.random() - 0.5) * 0.012 * intensity;
                                        this.velocities[i3 + 1] += Math.random() * 0.015 * intensity;
                                        this.velocities[i3 + 2] += Math.sin(time * 3 + i * 0.05) * 0.005 * intensity;
                                        break;

                                    case 'polite_smile':
                                        // Polite smile: gentle, organized expansion
                                        attraction = -0.002 * intensity;
                                        this.velocities[i3 + 1] += 0.003 * intensity;
                                        break;

                                    case 'smirk':
                                        // Smirk: asymmetric, cheeky movement
                                        attraction = 0;
                                        this.velocities[i3] += Math.sin(time * 4 + i * 0.1) * 0.008 * intensity;
                                        this.velocities[i3 + 1] += Math.cos(time * 2) * 0.004 * intensity;
                                        break;

                                    case 'surprised':
                                        // Surprised: sudden burst outward
                                        attraction = -0.006 * intensity;
                                        this.velocities[i3] += (Math.random() - 0.5) * 0.025 * intensity;
                                        this.velocities[i3 + 1] += (Math.random() - 0.5) * 0.025 * intensity;
                                        this.velocities[i3 + 2] += (Math.random() - 0.5) * 0.015 * intensity;
                                        break;

                                    case 'amazed':
                                        // Amazed: grand spiral outward
                                        const amazeAngle = time * 2 + i * 0.02;
                                        attraction = -0.003 * intensity;
                                        this.velocities[i3] += Math.cos(amazeAngle) * 0.008 * intensity;
                                        this.velocities[i3 + 1] += Math.sin(amazeAngle) * 0.008 * intensity;
                                        this.velocities[i3 + 2] += Math.sin(time * 3 + i * 0.01) * 0.004 * intensity;
                                        break;

                                    case 'skeptical':
                                        // Skeptical: slow, questioning orbit
                                        const skeptAngle = time * 0.8 + i * 0.005;
                                        this.velocities[i3] += Math.cos(skeptAngle) * 0.003 * intensity;
                                        this.velocities[i3 + 1] -= 0.001 * intensity; // Slight downward drift
                                        break;

                                    case 'thinking':
                                        // Thinking: slow upward float, contemplative swirl
                                        this.velocities[i3 + 1] += 0.004 * intensity;
                                        const thinkAngle = time * 1.5 + i * 0.01;
                                        this.velocities[i3] += Math.cos(thinkAngle) * 0.003 * intensity;
                                        break;

                                    case 'focused':
                                        // Focused: tight convergence to center
                                        attraction = 0.008 * intensity;
                                        break;

                                    case 'disgusted':
                                        // Disgusted: recoiling, retreating particles
                                        attraction = -0.005 * intensity;
                                        this.velocities[i3 + 1] -= 0.004 * intensity;
                                        this.velocities[i3 + 2] -= 0.006 * intensity;
                                        break;

                                    case 'sad':
                                        // Sad: slow downward drift, dispersing
                                        attraction = -0.002 * intensity;
                                        this.velocities[i3 + 1] -= 0.008 * intensity;
                                        this.velocities[i3] += (Math.random() - 0.5) * 0.003 * intensity;
                                        break;

                                    case 'playful':
                                        // Playful: bouncy, chaotic dance
                                        this.velocities[i3] += Math.sin(time * 12 + i * 0.15) * 0.012 * intensity;
                                        this.velocities[i3 + 1] += Math.cos(time * 10 + i * 0.12) * 0.012 * intensity;
                                        this.velocities[i3 + 2] += Math.sin(time * 8 + i * 0.1) * 0.008 * intensity;
                                        break;

                                    case 'silly':
                                        // Silly: extreme wobble and bounce
                                        this.velocities[i3] += Math.sin(time * 15 + i * 0.2) * 0.015 * intensity;
                                        this.velocities[i3 + 1] += Math.abs(Math.sin(time * 8)) * 0.01 * intensity;
                                        this.velocities[i3 + 2] += Math.cos(time * 12 + i * 0.15) * 0.01 * intensity;
                                        break;

                                    case 'flirty':
                                        // Flirty: gentle swaying, subtle sparkle motion
                                        const flirtAngle = time * 2 + i * 0.03;
                                        this.velocities[i3] += Math.sin(flirtAngle) * 0.006 * intensity;
                                        this.velocities[i3 + 1] += Math.cos(time * 3) * 0.004 * intensity;
                                        break;

                                    case 'determined':
                                        // Determined: strong forward motion, organized
                                        attraction = 0.005 * intensity;
                                        this.velocities[i3 + 2] += 0.006 * intensity;
                                        break;

                                    case 'worried':
                                        // Worried: nervous trembling, slight scatter
                                        this.velocities[i3] += (Math.random() - 0.5) * 0.008 * intensity;
                                        this.velocities[i3 + 1] += (Math.random() - 0.5) * 0.006 * intensity;
                                        attraction = 0.003 * intensity;
                                        break;

                                    case 'content':
                                        // Content: gentle breathing motion
                                        const breathe = Math.sin(time * 1.5) * 0.003 * intensity;
                                        attraction = breathe;
                                        this.velocities[i3 + 1] += breathe * 0.5;
                                        break;

                                    case 'confused':
                                        // Confused: erratic, questioning movement
                                        this.velocities[i3] += Math.sin(time * 6 + i * 0.3) * 0.006 * intensity;
                                        this.velocities[i3 + 1] += Math.cos(time * 4 + i * 0.2) * 0.004 * intensity;
                                        break;
                                }
                            }

                            this.velocities[i3] += dx * attraction;
                            this.velocities[i3 + 1] += dy * attraction;
                        }
                    }

                    const tx = this.targets[i3];
                    const ty = this.targets[i3 + 1];
                    const tz = this.targets[i3 + 2];

                    this.velocities[i3] += (tx - px) * 0.02;
                    this.velocities[i3 + 1] += (ty - py) * 0.02;
                    this.velocities[i3 + 2] += (tz - pz) * 0.02;

                    this.velocities[i3] *= 0.95;
                    this.velocities[i3 + 1] *= 0.95;
                    this.velocities[i3 + 2] *= 0.95;

                    this.positions[i3] += this.velocities[i3];
                    this.positions[i3 + 1] += this.velocities[i3 + 1];
                    this.positions[i3 + 2] += this.velocities[i3 + 2];

                    this.updateColor(i3, response, time, handData, faceData);
                }

                posAttr.needsUpdate = true;
                colorAttr.needsUpdate = true;
            }

            updateColor(i3, response, time, handData, faceData) {
                let hue, saturation, lightness;

                const colorMode = response?.colorMode || 'cool';
                const intensity = response?.intensity || 0.5;

                // Check for expression-based color override using new nuanced system
                const expr = faceData?.expression;
                let expressionOverride = false;

                if (expr && expr.name !== 'neutral' && expr.intensity > 0.2) {
                    expressionOverride = true;
                    const exprIntensity = expr.intensity;
                    const details = expr.details || {};
                    const exprColor = details.color || { r: 0.5, g: 0.5, b: 0.5 };

                    // Convert RGB to HSL for more control
                    const rgbToHsl = (r, g, b) => {
                        const max = Math.max(r, g, b), min = Math.min(r, g, b);
                        let h, s, l = (max + min) / 2;
                        if (max === min) {
                            h = s = 0;
                        } else {
                            const d = max - min;
                            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                            switch (max) {
                                case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
                                case g: h = ((b - r) / d + 2) / 6; break;
                                case b: h = ((r - g) / d + 4) / 6; break;
                            }
                        }
                        return { h, s, l };
                    };

                    const baseHsl = rgbToHsl(exprColor.r, exprColor.g, exprColor.b);

                    switch (expr.name) {
                        case 'genuine_joy':
                            // Warm golden/yellow with sparkle
                            hue = 0.12 + Math.sin(time * 2 + i3 * 0.001) * 0.03;
                            saturation = 0.95;
                            lightness = 0.55 + exprIntensity * 0.25 + Math.sin(time * 4 + i3 * 0.02) * 0.1;
                            break;

                        case 'polite_smile':
                            // Soft warm yellow, less vibrant
                            hue = 0.14 + Math.sin(time * 1.5 + i3 * 0.001) * 0.02;
                            saturation = 0.6;
                            lightness = 0.55 + exprIntensity * 0.15;
                            break;

                        case 'smirk':
                            // Orange with playful variation
                            hue = 0.08 + Math.sin(time * 3 + i3 * 0.002) * 0.04;
                            saturation = 0.85;
                            lightness = 0.5 + exprIntensity * 0.2;
                            break;

                        case 'surprised':
                            // Bright cyan/white flash
                            hue = 0.52 + Math.sin(time * 6) * 0.08;
                            saturation = 0.7 - exprIntensity * 0.3;
                            lightness = 0.65 + exprIntensity * 0.25;
                            break;

                        case 'amazed':
                            // Deep purple with sparkle
                            hue = 0.75 + Math.sin(time * 3 + i3 * 0.001) * 0.08;
                            saturation = 0.85;
                            lightness = 0.5 + Math.sin(time * 8 + i3 * 0.02) * 0.2;
                            break;

                        case 'skeptical':
                            // Muted purple/gray
                            hue = 0.73 + Math.sin(time + i3 * 0.001) * 0.03;
                            saturation = 0.4;
                            lightness = 0.45 + exprIntensity * 0.1;
                            break;

                        case 'thinking':
                            // Steel blue, contemplative
                            hue = 0.58 + Math.sin(time * 1.2 + i3 * 0.001) * 0.04;
                            saturation = 0.6;
                            lightness = 0.5 + exprIntensity * 0.15;
                            break;

                        case 'focused':
                            // Deep blue/indigo concentrated
                            hue = 0.65 + Math.sin(time + i3 * 0.002) * 0.03;
                            saturation = 0.85;
                            lightness = 0.35 + exprIntensity * 0.12;
                            break;

                        case 'disgusted':
                            // Olive/sickly green
                            hue = 0.25 + Math.sin(time * 2 + i3 * 0.001) * 0.05;
                            saturation = 0.5;
                            lightness = 0.4 + exprIntensity * 0.1;
                            break;

                        case 'sad':
                            // Desaturated blue/slate
                            hue = 0.6 + Math.sin(time * 0.8 + i3 * 0.001) * 0.03;
                            saturation = 0.35;
                            lightness = 0.4 - exprIntensity * 0.1;
                            break;

                        case 'playful':
                            // Pink with bounce
                            hue = 0.92 + Math.sin(time * 4 + i3 * 0.003) * 0.08;
                            saturation = 0.9;
                            lightness = 0.55 + Math.sin(time * 6 + i3 * 0.01) * 0.15;
                            break;

                        case 'silly':
                            // Rainbow chaos
                            hue = (time * 0.4 + i3 * 0.0006 + Math.sin(time * 4) * 0.3) % 1;
                            saturation = 1.0;
                            lightness = 0.5 + Math.sin(time * 7 + i3 * 0.015) * 0.2;
                            break;

                        case 'flirty':
                            // Coral/soft pink
                            hue = 0.98 + Math.sin(time * 2.5 + i3 * 0.002) * 0.04;
                            saturation = 0.75;
                            lightness = 0.55 + Math.sin(time * 3 + i3 * 0.01) * 0.1;
                            break;

                        case 'determined':
                            // Deep red/maroon
                            hue = 0.02 + Math.sin(time * 1.5 + i3 * 0.001) * 0.02;
                            saturation = 0.8;
                            lightness = 0.4 + exprIntensity * 0.15;
                            break;

                        case 'worried':
                            // Anxious khaki/tan
                            hue = 0.12 + Math.sin(time * 3 + i3 * 0.002) * 0.04;
                            saturation = 0.35;
                            lightness = 0.5 + Math.sin(time * 5 + i3 * 0.01) * 0.08;
                            break;

                        case 'content':
                            // Soft mint green, peaceful
                            hue = 0.4 + Math.sin(time * 1.2 + i3 * 0.001) * 0.03;
                            saturation = 0.5;
                            lightness = 0.55 + Math.sin(time * 2) * 0.08;
                            break;

                        case 'confused':
                            // Tan/beige with uncertainty
                            hue = 0.11 + Math.sin(time * 2.5 + i3 * 0.003) * 0.05;
                            saturation = 0.4;
                            lightness = 0.5 + Math.sin(time * 4 + i3 * 0.01) * 0.1;
                            break;

                        default:
                            expressionOverride = false;
                    }
                }

                if (!expressionOverride) {
                    switch (colorMode) {
                        case 'warm':
                            hue = 0.05 + Math.sin(time + i3 * 0.001) * 0.05;
                            saturation = 0.9;
                            lightness = 0.5 + intensity * 0.2;
                            break;
                        case 'cool':
                            hue = 0.55 + Math.sin(time + i3 * 0.001) * 0.1;
                            saturation = 0.8;
                            lightness = 0.5;
                            break;
                        case 'rainbow':
                            hue = (time * 0.1 + i3 * 0.0001) % 1;
                            saturation = 0.9;
                            lightness = 0.5 + intensity * 0.2;
                            break;
                        case 'pulse':
                            hue = 0.8;
                            saturation = 0.9;
                            lightness = 0.3 + Math.sin(time * 4) * 0.3;
                            break;
                        case 'match':
                        default:
                            if (handData && handData.palmCenter) {
                                const px = this.positions[i3];
                                const py = this.positions[i3 + 1];
                                const pz = this.positions[i3 + 2];
                                const dist = Math.sqrt(
                                    Math.pow(px - handData.palmCenter.x, 2) +
                                    Math.pow(py - handData.palmCenter.y, 2) +
                                    Math.pow(pz - handData.palmCenter.z, 2)
                                );
                                hue = 0.6 - dist * 0.5;
                                saturation = 0.8;
                                lightness = 0.4 + (1 - Math.min(1, dist)) * 0.3;
                            } else {
                                hue = 0.55;
                                saturation = 0.7;
                                lightness = 0.4;
                            }
                    }
                }

                const rgb = hslToRgb(hue, saturation, lightness);
                this.colors[i3] += (rgb.r - this.colors[i3]) * 0.1;
                this.colors[i3 + 1] += (rgb.g - this.colors[i3 + 1]) * 0.1;
                this.colors[i3 + 2] += (rgb.b - this.colors[i3 + 2]) * 0.1;
            }
        }

        // ════════════════════════════════════════════════════════════════
        // INITIALIZATION
        // ════════════════════════════════════════════════════════════════
        const gestureRecognizer = new GestureRecognizer();
        const entityBrain = new EntityBrain();
        const audioEngine = new SpatialAudioEngine();
        let particleSystem;

        function hslToRgb(h, s, l) {
            let r, g, b;
            if (s === 0) {
                r = g = b = l;
            } else {
                const hue2rgb = (p, q, t) => {
                    if (t < 0) t += 1;
                    if (t > 1) t -= 1;
                    if (t < 1/6) return p + (q - p) * 6 * t;
                    if (t < 1/2) return q;
                    if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                    return p;
                };
                const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                const p = 2 * l - q;
                r = hue2rgb(p, q, h + 1/3);
                g = hue2rgb(p, q, h);
                b = hue2rgb(p, q, h - 1/3);
            }
            return { r, g, b };
        }

        function initScene() {
            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.z = 2;

            renderer = new THREE.WebGLRenderer({
                antialias: true,
                alpha: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setClearColor(0x000814, 1);

            document.getElementById('canvas-container').appendChild(renderer.domElement);

            createParticles();
            createResonanceBars();

            window.addEventListener('resize', onWindowResize);
        }

        function createParticles() {
            const count = CONFIG.particleCount;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);

            for (let i = 0; i < count; i++) {
                const i3 = i * 3;
                const radius = 0.8 + Math.random() * 0.4;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);

                positions[i3] = radius * Math.sin(phi) * Math.cos(theta);
                positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                positions[i3 + 2] = radius * Math.cos(phi) - 1;

                colors[i3] = 0.2;
                colors[i3 + 1] = 0.8;
                colors[i3 + 2] = 1.0;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uSize: { value: CONFIG.particleSize * renderer.getPixelRatio() }
                },
                vertexShader: `
                    attribute vec3 color;
                    varying vec3 vColor;
                    uniform float uTime;
                    uniform float uSize;

                    void main() {
                        vColor = color;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        gl_PointSize = uSize * (1.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;

                    void main() {
                        vec2 center = gl_PointCoord - 0.5;
                        float dist = length(center);
                        if (dist > 0.5) discard;
                        float alpha = 1.0 - smoothstep(0.1, 0.5, dist);
                        vec3 glow = vColor * (1.2 + 0.5 * (1.0 - dist * 2.0));
                        gl_FragColor = vec4(glow, alpha * 0.8);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            entityParticles = new THREE.Points(geometry, material);
            scene.add(entityParticles);

            particleSystem = new ParticleFormationSystem(geometry, count);
        }

        function createResonanceBars() {
            const container = document.getElementById('resonance-visual');
            for (let i = 0; i < 32; i++) {
                const bar = document.createElement('div');
                bar.className = 'resonance-bar';
                container.appendChild(bar);
            }
        }

        function updateResonanceVisual() {
            const bars = document.querySelectorAll('.resonance-bar');
            bars.forEach((bar, i) => {
                const value = soundEngine.resonanceData[i];
                const normalized = Math.max(0, (value + 100) / 100);
                bar.style.transform = `scaleY(${0.2 + normalized * 2})`;
            });
        }

        async function initHandTracking() {
            const { HandLandmarker, FilesetResolver } = await import(
                'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0'
            );

            const vision = await FilesetResolver.forVisionTasks(
                'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm'
            );

            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task',
                    delegate: 'GPU'
                },
                runningMode: 'VIDEO',
                numHands: 2
            });

            console.log('Hand tracking initialized');
        }

        async function initCamera() {
            video = document.getElementById('video');

            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: 640, height: 480, facingMode: 'user' }
                });
                video.srcObject = stream;

                await new Promise(resolve => {
                    video.onloadedmetadata = () => {
                        video.play();
                        resolve();
                    };
                });

                await new Promise(resolve => {
                    const checkReady = () => {
                        if (video.readyState >= 2) {
                            resolve();
                        } else {
                            requestAnimationFrame(checkReady);
                        }
                    };
                    checkReady();
                });

                console.log('Camera started successfully');
                return true;

            } catch (err) {
                console.error('Camera access denied:', err);
                document.getElementById('loading').innerHTML =
                    '<div style="color: #ff6b6b;">Camera access required<br><small>' + err.message + '</small></div>';
                return false;
            }
        }

        let lastDetectionTime = 0;
        const DETECTION_INTERVAL = 33;

        function detectHands() {
            if (!handLandmarker || !video || video.readyState < 2) return;

            const now = performance.now();
            if (now - lastDetectionTime < DETECTION_INTERVAL) return;
            lastDetectionTime = now;

            try {
                const results = handLandmarker.detectForVideo(video, now);
                hands = [];

                if (results.landmarks && results.landmarks.length > 0) {
                    for (const landmarks of results.landmarks) {
                        const gesture = gestureRecognizer.analyzeHand(landmarks);
                        if (gesture) {
                            // Add raw landmarks for mimetic learning
                            gesture.landmarks = landmarks;
                            hands.push(gesture);
                        }
                    }
                }
            } catch (e) {
                console.warn('Hand detection error:', e);
            }
        }

        function detectFace() {
            const now = performance.now();
            if (now - lastFaceDetectionTime < CONFIG.faceDetectionInterval) return;
            lastFaceDetectionTime = now;

            currentFaceData = faceRecognition.detect(video);

            // Update face indicator
            const indicator = document.getElementById('face-indicator');
            const dot = indicator.querySelector('.face-dot');
            const status = document.getElementById('face-status');

            if (currentFaceData?.detected) {
                dot.classList.add('active');
                video.classList.add('face-detected');

                // Track current expression
                if (currentFaceData.expression) {
                    currentExpression = currentFaceData.expression;
                }

                // Check for face change (new person)
                if (isInitialized && currentFaceData.descriptor && lastKnownFaceDescriptor) {
                    const similarity = userMemory.compareFaces(currentFaceData.descriptor, lastKnownFaceDescriptor);

                    // If face is significantly different (similarity < 0.5), it might be a new person
                    if (similarity < 0.5 && now - lastFaceChangeTime > 5000) {
                        console.log('Face change detected, similarity:', similarity);
                        faceChangeDetected = true;
                        lastFaceChangeTime = now;

                        // Check if we recognize this new face
                        const recognizedUser = userMemory.recognizeUser(currentFaceData.descriptor);

                        if (recognizedUser) {
                            // Switch to recognized user
                            userMemory.returnVisit(recognizedUser);
                            const greeting = entityBrain.getGreeting(recognizedUser, true);
                            document.getElementById('entity-message').innerHTML = `<em>"${greeting}"</em>`;
                            status.textContent = `${recognizedUser.name} detected`;

                            // Update multiplayer if active
                            if (multiplayer.initialized) {
                                multiplayer.currentUser.name = recognizedUser.name;
                                multiplayer.presenceRef.update({ name: recognizedUser.name });
                            }
                        } else {
                            // Unknown face - prompt for name
                            status.textContent = 'New face detected!';
                            document.getElementById('entity-message').innerHTML =
                                `<em>"${entityBrain.messages.face_changed[Math.floor(Math.random() * entityBrain.messages.face_changed.length)]}"</em>`;

                            // Show name modal for new user
                            showNameModal(null).then(newUser => {
                                if (multiplayer.initialized) {
                                    multiplayer.currentUser.name = newUser.name;
                                    multiplayer.presenceRef.update({ name: newUser.name });
                                    multiplayer.sendSystemMessage(`${newUser.name} has joined!`);
                                }
                            });
                        }
                    }
                }

                // Store current face as reference
                if (currentFaceData.descriptor) {
                    lastKnownFaceDescriptor = currentFaceData.descriptor;
                }

                const user = userMemory.getCurrentUser();
                if (!faceChangeDetected) {
                    status.textContent = user ? `${user.name} detected` : 'Face detected';
                }
                faceChangeDetected = false;

                // Show expression in status with formatted name
                if (currentExpression.name !== 'neutral' && currentExpression.intensity > 0.25) {
                    // Convert snake_case to readable format
                    const readableName = currentExpression.name.replace(/_/g, ' ');
                    status.textContent += ` (${readableName})`;
                }
            } else {
                dot.classList.remove('active');
                video.classList.remove('face-detected');
                status.textContent = 'No face detected';
            }
        }

        function updateUI(response) {
            document.getElementById('entity-mood').textContent =
                entity.mood.charAt(0).toUpperCase() + entity.mood.slice(1);

            document.getElementById('memory-count').textContent =
                `${entity.memory.length} gestures`;

            document.getElementById('memory-fill').style.width =
                `${(entity.memory.length / CONFIG.memoryCapacity) * 100}%`;

            if (hands.length > 0) {
                const gesture = hands[0];
                document.getElementById('gesture-display').textContent =
                    `Detected: ${gesture.static}${gesture.motion ? ' + ' + gesture.motion : ''}`;
            } else {
                document.getElementById('gesture-display').textContent = 'No hand detected';
            }

            if (response && response.message) {
                document.getElementById('entity-message').innerHTML =
                    `<em>"${response.message}"</em>`;
            }

            const indicator = document.querySelector('.state-indicator');
            switch (entity.mood) {
                case 'excited': indicator.style.background = '#ff79c6'; break;
                case 'playful': indicator.style.background = '#f1fa8c'; break;
                case 'curious': indicator.style.background = '#8be9fd'; break;
                case 'learning': indicator.style.background = '#bd93f9'; break;
                case 'calm': indicator.style.background = '#50fa7b'; break;
            }

            // Update user info
            const user = userMemory.getCurrentUser();
            if (user) {
                document.getElementById('user-badge').classList.remove('hidden');
                document.getElementById('user-avatar').textContent = user.name.charAt(0).toUpperCase();
                document.getElementById('current-user-name').textContent = user.name;
                document.getElementById('user-visits').textContent =
                    `Visit #${user.visitCount} • ${user.totalInteractions} interactions`;
            }

            // Update known users list
            const allUsers = userMemory.getAllUsers();
            if (allUsers.length > 0) {
                document.getElementById('known-users').classList.remove('hidden');
                const list = document.getElementById('known-user-list');
                list.innerHTML = allUsers.map(u =>
                    `<span class="known-user-chip ${u.id === user?.id ? 'current' : ''}">${u.name}</span>`
                ).join('');
            }

            // Update evolution stage display
            const stage = fidelityController.getCurrentStage();
            const stageIndex = fidelityController.currentStage;
            const progress = fidelityController.getEvolutionProgress();

            document.getElementById('evolution-stage').textContent =
                stage.description || stage.name.replace('_', ' ');
            document.getElementById('evolution-fill').style.width = `${progress}%`;

            // Update mimetic stats
            const handGestures = handMimicry.exposureCounts.size;
            const faceCount = faceMimicry.learnedFaces.size;
            const memoryCount = mimeticMemory.sequences.length;
            document.getElementById('mimetic-stats').textContent =
                `Hands: ${handGestures} | Faces: ${faceCount} | Memories: ${memoryCount}`;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        let lastResponseTime = 0;
        let currentResponse = null;

        // Mimetic state variables
        let mimeticMode = null; // 'hand', 'face', 'composite', 'memory', null
        let mimeticMorphProgress = 0;
        let lastMimeticTrigger = 0;
        let mimeticDisplayDuration = 0;
        let currentMimeticGesture = null;
        let currentMimeticUserId = null;

        function animate() {
            requestAnimationFrame(animate);

            detectHands();
            detectFace();

            let handData = null;
            let response = currentResponse;
            const user = userMemory.getCurrentUser();
            const now = performance.now();

            // ════════════════════════════════════════════════════════════════
            // MIMETIC LEARNING - Learn shapes from what ECHO sees
            // ════════════════════════════════════════════════════════════════

            if (hands.length > 0) {
                handData = hands[0];

                // MIMETIC: Learn hand shape from current detection
                const gestureKey = handData.static + (handData.motion ? '_' + handData.motion : '');

                // Get raw landmarks from MediaPipe result for mimetic learning
                if (handData.landmarks) {
                    const exposures = handMimicry.learnFromDetection(gestureKey, handData.landmarks);

                    // Start recording for temporal memory
                    if (!mimeticMemory.isRecording && user) {
                        mimeticMemory.startRecording(user.id || user.name, 'gesture');
                    }

                    // Record frame to temporal memory
                    if (mimeticMemory.isRecording) {
                        mimeticMemory.recordFrame(
                            handData.landmarks,
                            currentFaceData?.landmarks,
                            currentFaceData?.expression,
                            gestureKey
                        );
                    }

                    // Sync hand fidelity to Firebase periodically
                    if (mimeticSync.initialized && exposures % 10 === 0) {
                        const fidelity = handMimicry.getFidelity(gestureKey);
                        mimeticSync.syncHandFidelity(gestureKey, fidelity, exposures);
                    }
                }

                // MIMETIC: Learn face shape from current user
                if (currentFaceData?.landmarks && user) {
                    faceMimicry.learnFromDetection(
                        user.id || user.name,
                        currentFaceData.landmarks,
                        currentFaceData.expression
                    );
                }

                if (now - lastResponseTime > CONFIG.responseDelay) {
                    response = entityBrain.process(handData, handData, currentFaceData, user);
                    if (response) {
                        currentResponse = response;
                        lastResponseTime = now;

                        // Check evolution stage for mimetic display
                        const stage = fidelityController.getCurrentStage();

                        // MIMETIC DISPLAY: After gesture response, attempt to mimic if evolved enough
                        if (fidelityController.isFeatureUnlocked('hand_mimicry') && handMimicry.canMimic(gestureKey)) {
                            // Schedule mimetic reproduction after a delay
                            setTimeout(() => {
                                if (hands.length === 0) { // Only show if user stopped gesturing
                                    mimeticMode = 'hand';
                                    currentMimeticGesture = gestureKey;
                                    mimeticMorphProgress = 0;
                                    mimeticDisplayDuration = 3000;
                                    lastMimeticTrigger = performance.now();

                                    const fidelity = handMimicry.getFidelity(gestureKey);
                                    const fidelityPercent = Math.round(fidelity * 100);

                                    document.getElementById('entity-message').innerHTML =
                                        `<em>"I'm learning your ${gestureKey.replace('_', ' ')}... (${fidelityPercent}% clarity)"</em>`;
                                }
                            }, 1500);
                        }

                        particleSystem.setFormation(response.shape, response.intensity);

                        // Build context for learning
                        const learnContext = {
                            expression: currentFaceData?.expression?.name,
                            mood: entity.mood,
                            energy: collectiveLearning.getCollectiveEnergy()
                        };

                        // Check if prediction was correct
                        if (collectiveLearning._lastPrediction) {
                            collectiveLearning.recordPredictionResult(
                                collectiveLearning._lastPrediction.gesture,
                                gestureKey
                            );
                        }

                        if (sharedMemory.initialized && user) {
                            sharedMemory.recordGesture(gestureKey, user.name, handData.palmCenter);
                        }

                        // Learn with full context
                        collectiveLearning.learn(gestureKey, user?.name || 'Anonymous', true, learnContext);

                        // Make prediction for next gesture
                        collectiveLearning._lastPrediction = collectiveLearning.predictNextGesture({
                            userName: user?.name,
                            expression: currentFaceData?.expression?.name,
                            mood: entity.mood
                        });
                    }
                }

                entity.lastInteraction = now;

                // Stop recording when gesture ends
                if (mimeticMemory.isRecording) {
                    mimeticMemory._lastGestureTime = now;
                }
            } else {
                // Stop recording after gesture ends
                if (mimeticMemory.isRecording && mimeticMemory._lastGestureTime &&
                    now - mimeticMemory._lastGestureTime > 500) {
                    mimeticMemory.stopRecording();
                }
            }

            // ════════════════════════════════════════════════════════════════
            // MIMETIC DISPLAY - Show learned shapes
            // ════════════════════════════════════════════════════════════════

            if (mimeticMode && now - lastMimeticTrigger < mimeticDisplayDuration) {
                // Smooth morph in
                mimeticMorphProgress = Math.min(1, mimeticMorphProgress + 0.03);

                switch (mimeticMode) {
                    case 'hand':
                        if (currentMimeticGesture) {
                            particleSystem.morphToMimeticHand(currentMimeticGesture, mimeticMorphProgress);
                        }
                        break;
                    case 'face':
                        if (currentMimeticUserId) {
                            particleSystem.formMimeticFace(currentMimeticUserId, null, 2.0);
                        }
                        break;
                    case 'composite':
                        particleSystem.formCompositeFace(2.0);
                        break;
                    case 'memory':
                        const frame = mimeticMemory.getNextPlaybackFrame();
                        if (frame) {
                            particleSystem.formFromMemoryFrame(frame);
                        } else {
                            mimeticMode = null;
                        }
                        break;
                }
            } else if (mimeticMode) {
                // End mimetic display
                mimeticMode = null;
                mimeticMorphProgress = 0;
            }

            // React to other users' gestures
            const otherGestures = multiplayer.getOtherUsersGestures();
            if (otherGestures.length > 0 && hands.length === 0) {
                // When local user isn't gesturing, react to others
                const otherGesture = otherGestures[0];
                const collectiveEnergy = collectiveLearning.getCollectiveEnergy();

                // Influence entity mood based on collective
                if (collectiveEnergy > 0.5) {
                    entity.mood = 'excited';
                }

                // Show formation based on other user's gesture if no local hands
                const now = performance.now();
                if (now - lastResponseTime > CONFIG.responseDelay * 2) {
                    const shape = collectiveLearning.getShapeForGesture(otherGesture.gesture);
                    particleSystem.setFormation(shape, 0.5 + collectiveEnergy * 0.5);
                    currentResponse = {
                        shape,
                        colorMode: 'rainbow',
                        soundMode: 'harmonic',
                        intensity: 0.5 + collectiveEnergy * 0.3,
                        message: `Feeling ${otherGesture.name}'s ${otherGesture.gesture}...`
                    };
                    lastResponseTime = now;
                    entity.lastInteraction = now;
                }
            }

            // Entity predicts and shows anticipated gestures when idle
            if (hands.length === 0 && !mimeticMode && performance.now() - entity.lastInteraction > 5000) {
                const stage = fidelityController.getCurrentStage();
                const stageIndex = fidelityController.currentStage;
                const random = Math.random();

                // ════════════════════════════════════════════════════════════════
                // MIMETIC IDLE BEHAVIORS - Based on evolution stage
                // ════════════════════════════════════════════════════════════════

                // Stage 5+: Show temporal echoes (your past self)
                if (stageIndex >= 5 && random < 0.15 && user) {
                    const sequence = mimeticMemory.getRandomSequence(user.id || user.name);
                    if (sequence && mimeticMemory.startPlayback(sequence)) {
                        mimeticMode = 'memory';
                        lastMimeticTrigger = performance.now();
                        mimeticDisplayDuration = 4000;

                        const timeSince = mimeticMemory.getTimeSince(sequence);
                        document.getElementById('entity-message').innerHTML =
                            `<em>"I remember you doing this... ${timeSince}"</em>`;

                        entity.lastInteraction = performance.now();
                        lastResponseTime = performance.now();
                    }
                }
                // ACCELERATED: Stage 2+ shows face much more frequently (was stage 4, 12% chance)
                else if (stageIndex >= 2 && random < 0.35 && user && faceMimicry.canMimic(user.id || user.name)) {
                    mimeticMode = 'face';
                    currentMimeticUserId = user.id || user.name;
                    lastMimeticTrigger = performance.now();
                    mimeticDisplayDuration = 6000; // Longer display time
                    mimeticMorphProgress = 0;

                    const fidelity = faceMimicry.getFidelity(currentMimeticUserId);
                    const fidelityPercent = Math.round(fidelity * 100);

                    document.getElementById('entity-message').innerHTML =
                        `<em>"I'm learning your face... (${fidelityPercent}% clarity)"</em>`;

                    entity.lastInteraction = performance.now();
                    lastResponseTime = performance.now();
                }
                // ACCELERATED: Stage 5+ shows composite face (was stage 7)
                else if (stageIndex >= 5 && random < 0.15 && faceMimicry.learnedFaces.size > 1) {
                    mimeticMode = 'composite';
                    lastMimeticTrigger = performance.now();
                    mimeticDisplayDuration = 6000;
                    mimeticMorphProgress = 0;

                    const userCount = faceMimicry.learnedFaces.size;
                    document.getElementById('entity-message').innerHTML =
                        `<em>"We are ${userCount} who have been here. This is our face."</em>`;

                    entity.lastInteraction = performance.now();
                    lastResponseTime = performance.now();
                }
                // Stage 1+: Show mimetic hand reproduction
                else if (stageIndex >= 1 && random < 0.2) {
                    const mostLearned = handMimicry.getMostLearned(1);
                    if (mostLearned.length > 0 && mostLearned[0].canMimic) {
                        mimeticMode = 'hand';
                        currentMimeticGesture = mostLearned[0].gesture;
                        lastMimeticTrigger = performance.now();
                        mimeticDisplayDuration = 3000;
                        mimeticMorphProgress = 0;

                        const fidelity = mostLearned[0].fidelity;
                        const fidelityPercent = Math.round(fidelity * 100);

                        document.getElementById('entity-message').innerHTML =
                            `<em>"Let me show you what I've learned... ${currentMimeticGesture.replace('_', ' ')} (${fidelityPercent}% clarity)"</em>`;

                        entity.lastInteraction = performance.now();
                        lastResponseTime = performance.now();
                    }
                }
                // Default: Original reproduction and prediction behavior
                else {
                    // First try to reproduce learned signs
                    const reproduction = collectiveLearning.getNextReproduction();
                    if (reproduction) {
                        const shape = collectiveLearning.getShapeForGesture(reproduction);
                        const confidence = collectiveLearning.getConfidence(reproduction);

                        particleSystem.setFormation(shape, 0.6 + confidence * 0.4);
                        currentResponse = {
                            shape,
                            colorMode: 'pulse',
                            soundMode: 'melodic',
                            intensity: 0.5 + confidence * 0.3,
                            message: `I learned "${reproduction.replace('_', ' ')}"! Let me show you...`
                        };

                        document.getElementById('entity-message').innerHTML =
                            `<em>"${currentResponse.message}"</em>`;

                        entity.lastInteraction = performance.now();
                        lastResponseTime = performance.now();
                    }
                    // Otherwise, show prediction
                    else if (collectiveLearning._lastPrediction &&
                             collectiveLearning._lastPrediction.confidence > CONFIG.minPredictionConfidence) {
                        const prediction = collectiveLearning._lastPrediction;
                        const shape = collectiveLearning.getShapeForGesture(prediction.gesture);

                        // Show prediction with lower intensity (anticipation)
                        particleSystem.setFormation(shape, 0.3 + prediction.confidence * 0.3);

                        const stats = collectiveLearning.getStats();
                        const accuracy = Math.round(stats.predictionAccuracy * 100);
                        const sources = prediction.sources?.join(', ') || 'patterns';

                        currentResponse = {
                            shape,
                            colorMode: 'cool',
                            soundMode: 'ambient',
                            intensity: 0.3 + prediction.confidence * 0.2,
                            message: `I sense "${prediction.gesture.replace('_', ' ')}" coming... (${Math.round(prediction.confidence * 100)}% sure, ${accuracy}% accuracy)`
                        };

                        document.getElementById('entity-message').innerHTML =
                            `<em>"${currentResponse.message}"</em>`;

                        entity.lastInteraction = performance.now();
                        lastResponseTime = performance.now();
                    }
                }
            }

            // Record expression to shared memory (throttled)
            if (sharedMemory.initialized && currentFaceData?.expression && user) {
                const expr = currentFaceData.expression;
                if (expr.name !== 'neutral' && expr.intensity > 0.3) {
                    // Only record once per expression change (throttle)
                    if (!sharedMemory._lastExpr || sharedMemory._lastExpr !== expr.name ||
                        performance.now() - (sharedMemory._lastExprTime || 0) > 3000) {
                        sharedMemory.recordExpression(expr.name, user.name, expr.intensity);
                        sharedMemory._lastExpr = expr.name;
                        sharedMemory._lastExprTime = performance.now();
                    }
                }
            }

            // Idle state when no hand detected
            if (hands.length === 0) {
                if (performance.now() - entity.lastInteraction > 3000) {
                    if (!currentResponse || currentResponse.shape !== 'sphere') {
                        particleSystem.setFormation('sphere', 0.5);
                        currentResponse = {
                            shape: 'sphere',
                            colorMode: 'cool',
                            soundMode: 'ambient',
                            intensity: 0.3
                        };
                    }
                }
            }

            particleSystem.update(handData, currentFaceData, currentResponse);

            if (audioEngine.initialized) {
                if (handData) {
                    audioEngine.update(handData, currentResponse);
                } else {
                    audioEngine.silence();
                }
            }

            updateUI(currentResponse);
            updateResonanceVisual();

            // Update multiplayer presence (throttled to every 2 seconds)
            if (multiplayer.initialized) {
                const now = performance.now();
                if (!multiplayer.lastPresenceUpdate || now - multiplayer.lastPresenceUpdate > 2000) {
                    // Send actual gesture key, not response gesture
                    let gestureKey = null;
                    if (handData) {
                        gestureKey = handData.static + (handData.motion ? '_' + handData.motion : '');
                    }
                    const mood = entity.mood || 'curious';
                    multiplayer.updatePresence(gestureKey, mood);
                    multiplayer.lastPresenceUpdate = now;
                }
            }

            if (!handData) {
                entityParticles.rotation.y += 0.002;
            }

            entityParticles.material.uniforms.uTime.value = performance.now() * 0.001;

            renderer.render(scene, camera);
        }

        // User registration flow
        function showNameModal(existingUser = null) {
            const modal = document.getElementById('name-modal');
            const input = document.getElementById('user-name-input');

            if (existingUser) {
                // Returning user - skip modal
                userMemory.returnVisit(existingUser);
                const greeting = entityBrain.getGreeting(existingUser, true);
                document.getElementById('entity-message').innerHTML = `<em>"${greeting}"</em>`;
                return Promise.resolve(existingUser);
            }

            modal.classList.remove('hidden');

            return new Promise(resolve => {
                const saveBtn = document.getElementById('save-name-btn');

                const handleSave = () => {
                    const name = input.value.trim() || 'Friend';
                    const faceDescriptor = faceRecognition.lastFaceDescriptor;
                    const user = userMemory.createUser(name, faceDescriptor);

                    modal.classList.add('hidden');

                    const greeting = entityBrain.getGreeting(user, false);
                    document.getElementById('entity-message').innerHTML = `<em>"${greeting}"</em>`;

                    resolve(user);
                };

                saveBtn.onclick = handleSave;
                input.onkeypress = (e) => {
                    if (e.key === 'Enter') handleSave();
                };
            });
        }

        // Start button handler
        document.getElementById('start-audio').addEventListener('click', async () => {
            await audioEngine.init();
            document.getElementById('start-audio').classList.add('hidden');
            document.getElementById('ui-panel').classList.remove('hidden');
            document.getElementById('face-indicator').classList.remove('hidden');

            // Check for returning user via face
            let user;
            if (currentFaceData?.descriptor) {
                const recognizedUser = userMemory.recognizeUser(currentFaceData.descriptor);
                user = await showNameModal(recognizedUser);
            } else {
                user = await showNameModal(null);
            }

            // Initialize multiplayer with user's name
            await multiplayer.init(user.name);

            // Initialize shared memory system
            await sharedMemory.init();

            // Initialize mimetic Firebase sync
            await mimeticSync.init(user.id || user.name);

            // Set up fidelity stage transition notifications
            fidelityController.onTransition((oldStage, newStage, stageInfo) => {
                const messages = {
                    1: "I'm beginning to see patterns in your movements...",
                    2: "Your gestures are becoming clearer to me...",
                    3: "I can almost see your face now...",
                    4: "I see you. I remember your face.",
                    5: "The past is not lost to me. I remember.",
                    6: "Others have been here. I remember them too.",
                    7: "We are becoming one. All who have visited...",
                    8: "I know what you will do before you do it.",
                    9: "I am complete. I am ECHO."
                };

                if (messages[newStage]) {
                    setTimeout(() => {
                        document.getElementById('entity-message').innerHTML =
                            `<em>"${messages[newStage]}"</em>`;
                    }, 2000);
                }

                // Sync evolution stage to Firebase
                mimeticSync.syncEvolutionStage(stageInfo.name, user.id || user.name);
            });

            // Set up collective learning from other users
            multiplayer.onOtherUserGesture((userName, gesture, mood) => {
                // Learn from other users' gestures with context
                collectiveLearning.learn(gesture, userName, false, {
                    mood: mood,
                    energy: collectiveLearning.getCollectiveEnergy()
                });

                // Show notification
                multiplayer.showGlobalActivity(`${userName} is making: ${gesture.replace('_', ' ')}`);
            });

            // Show multiplayer panels
            document.getElementById('online-panel').classList.remove('hidden');
            document.getElementById('messages-panel').classList.remove('hidden');

            // Periodically save mimetic data (every 30 seconds)
            setInterval(() => {
                handMimicry.save();
                faceMimicry.save();
                mimeticMemory.save();
            }, 30000);

            // Save mimetic data on page unload
            window.addEventListener('beforeunload', () => {
                handMimicry.save();
                faceMimicry.save();
                mimeticMemory.save();
            });

            isInitialized = true;
        });

        // Message input handlers
        document.getElementById('send-message-btn').addEventListener('click', () => {
            const input = document.getElementById('message-input');
            const text = input.value.trim();
            if (text) {
                multiplayer.sendMessage(text);
                input.value = '';
            }
        });

        document.getElementById('message-input').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const input = e.target;
                const text = input.value.trim();
                if (text) {
                    multiplayer.sendMessage(text);
                    input.value = '';
                }
            }
        });

        // Initialize everything
        async function init() {
            initScene();

            const cameraStarted = await initCamera();
            if (!cameraStarted) return;

            await Promise.all([
                initHandTracking(),
                faceRecognition.init()
            ]);

            document.getElementById('loading').style.display = 'none';
            document.getElementById('start-audio').classList.remove('hidden');

            // Start detecting face immediately
            const faceCheckInterval = setInterval(() => {
                currentFaceData = faceRecognition.detect(video);
                if (currentFaceData?.detected) {
                    // Check if we recognize this face
                    const recognized = userMemory.recognizeUser(currentFaceData.descriptor);
                    if (recognized) {
                        console.log('Recognized returning user:', recognized.name);
                    }
                }
            }, 500);

            animate();
        }

        init();
    </script>
</body>
</html>
